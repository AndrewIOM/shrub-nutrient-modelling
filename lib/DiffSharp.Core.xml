<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>DiffSharp.Core</name></assembly>
<members>
<member name="T:DiffSharp.Backend.Other">
<summary>
 Reserved for future use
</summary>
</member>
<member name="T:DiffSharp.Backend.Torch">
<summary>
 The LibTorch backend 
</summary>
</member>
<member name="T:DiffSharp.Backend.Reference">
<summary>
 The reference backend 
</summary>
</member>
<member name="P:DiffSharp.Backend.Name">
<summary>
 Get the name of the backend
</summary>
</member>
<member name="T:DiffSharp.Backend">
<summary>
 Represents a backend for DiffSharp tensors
</summary>
</member>
<member name="T:DiffSharp.Device">
<summary>
 Represents a device specification.
</summary>
</member>
<member name="T:DiffSharp.DeviceType">
 <summary>
   Represents the type of a device. 
 </summary>

 <remarks>
   The numeric values used are as for LibTorch.
 </remarks>

 <namespacedoc>
   <summary>Contains fundamental types for the tensor programming model, including Tensor, Shape and dsharp.</summary>
 </namespacedoc>
</member>
<member name="T:DiffSharp.Dtype.Bool">
<summary>
 Store elements as booleans
</summary>
</member>
<member name="T:DiffSharp.Dtype.Int64">
<summary>
 Store elements as 64-bit signed integers
</summary>
</member>
<member name="T:DiffSharp.Dtype.Int32">
<summary>
 Store elements as 32-bit signed integers
</summary>
</member>
<member name="T:DiffSharp.Dtype.Int16">
<summary>
 Store elements as 16-bit signed integers
</summary>
</member>
<member name="T:DiffSharp.Dtype.Byte">
<summary>
 Store elements as 8-bit unsigned integers
</summary>
</member>
<member name="T:DiffSharp.Dtype.Int8">
<summary>
 Store elements as 8-bit integers
</summary>
</member>
<member name="T:DiffSharp.Dtype.Float64">
<summary>
 Store elements as 64-bit floating point numbers
</summary>
</member>
<member name="T:DiffSharp.Dtype.Float32">
<summary>
 Store elements as 32-bit floating point numbers
</summary>
</member>
<member name="T:DiffSharp.Dtype.Float16">
<summary>
 Store elements as 16-bit floating point numbers
</summary>
</member>
<member name="T:DiffSharp.Dtype.BFloat16">
<summary>
 Store elements as 16-bit floating point numbers (bfloat16 variation)
</summary>
</member>
<member name="P:DiffSharp.Dtype.SummationType">
<summary>
 Gets the natural result of the Sum(), SumToSize() and Sum(dim) operation on this dtype
</summary>
</member>
<member name="T:DiffSharp.Dtype">
<summary>
 Represents a storage type for elements of a tensor
</summary>
</member>
<member name="T:DiffSharp.Shape">
<summary>
 Represents the shape of a tensor.
</summary>
</member>
<member name="T:DiffSharp.scalar">
<summary>
 Represents a scalar on the DiffSharp programming model
</summary>
</member>
<member name="M:DiffSharp.BinaryOpElementwise.dfdb(DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Derivative of the function with respect to its second argument, \( \frac{\partial f(a, b)}{\partial b} \).</summary>
 <param name="a">The first argument \( a \)</param>
 <param name="b">The second argument \( b \)</param>
 <param name="f">The function's pre-computed primal evaluation result \( f(a, b) \), which can be one of the terms involved in the derivative computation (e.g., the derivative of the exponential function) and be used without the need to recompute it.</param>
 <returns>The tensor corresponding to \( \frac{\partial f(a, b)}{\partial b} \).</returns>
</member>
<member name="M:DiffSharp.BinaryOpElementwise.dfda(DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Derivative of the function with respect to its first argument, \( \frac{\partial f(a, b)}{\partial a} \).</summary>
 <param name="a">The first argument \( a \)</param>
 <param name="b">The second argument \( b \)</param>
 <param name="f">The function's pre-computed primal evaluation result \( f(a, b) \), which can be one of the terms involved in the derivative computation (e.g., the derivative of the exponential function) and be used without the need to recompute it.</param>
 <returns>The tensor corresponding to \( \frac{\partial f(a, b)}{\partial a} \).</returns>
</member>
<member name="T:DiffSharp.BinaryOpElementwise">
 <summary>Defines a new op implementing an elementwise binary function and its derivatives. Instances of this class are used with the <see cref="M:DiffSharp.Tensor.Op(DiffSharp.BinaryOp)"/> method to define a new differentiable tensor function that supports forward, reverse, and nested differentiation.</summary>
 <remarks>
 This type is specialized to elementwise ops. It requires the user to specify only (1) the <see cref="T:DiffSharp.Backends.RawTensor"/> operation and (2) the derivative of the function with respect to each argument. The corresponding derivative propagation rules for the forward and reverse differentiation modes are automatically generated.
 <para>If you are implementing a complex op that is not elementwise, you can use the generic type <see cref="T:DiffSharp.BinaryOp"/>, which allows you to define the full derivative propagation rules.</para>
 </remarks>
 <example>
 <code>
 { new BinaryOpElementwise("pow") with
     member _.fRaw(a,b) = a.PowTT(b)
     member _.dfda(a,b,f) = b * f / a
     member _.dfdb(a,b,f) = f * a.log()
 }
 
 { new BinaryOpElementwise("mul") with
     member _.fRaw(a,b) = a.MulTT(b)
     member _.dfda(a,b,f) = b
     member _.dfdb(a,b,f) = a
 }
 </code>
 </example>
</member>
<member name="P:DiffSharp.BinaryOp.name">
<summary>
 Name of the op.
</summary>
</member>
<member name="M:DiffSharp.BinaryOp.fd_dfdb(DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Derivative propagation rule for reverse differentiation mode for the partial derivative with respect to the second argument of the function. This represents the derivative of a value \( y \), which comes later in the computation graph than the function's value \( f(a, b) \), with respect to the function's second argument \( b \). In other words, it computes \( \frac{\partial y}{\partial b} = \frac{\partial y}{\partial f(a, b)} \frac{\partial f(a, b)}{\partial b} \).</summary>
 <param name="a">The first argument \( a \).</param>
 <param name="b">The second argument \( b \).</param>
 <param name="f">The function's pre-computed primal evaluation result \( f(a, b) \), which can be one of the terms involved in the derivative computation (e.g., the derivative of the exponential function) and be used without the need to recompute it.</param>
 <param name="fd">The derivative with respect to the function's output \( \frac{\partial y}{\partial f(a, b)} \).</param>
 <returns>The tensor corresponding to \( \frac{\partial y}{\partial b} = \frac{\partial y}{\partial f(a, b)} \frac{\partial f(a, b)}{\partial b} \).</returns>
</member>
<member name="M:DiffSharp.BinaryOp.fd_dfda(DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Derivative propagation rule for reverse differentiation mode for the partial derivative with respect to the first argument of the function. This represents the derivative of a value \( y \), which comes later in the computation graph than the function's value \( f(a, b) \), with respect to the function's first argument \( a \). In other words, it computes \( \frac{\partial y}{\partial a} = \frac{\partial y}{\partial f(a, b)} \frac{\partial f(a, b)}{\partial a} \).</summary>
 <param name="a">The first argument \( a \).</param>
 <param name="b">The second argument \( b \).</param>
 <param name="f">The function's pre-computed primal evaluation result \( f(a, b) \), which can be one of the terms involved in the derivative computation (e.g., the derivative of the exponential function) and be used without the need to recompute it.</param>
 <param name="fd">The derivative with respect to the function's output \( \frac{\partial y}{\partial f(a, b)} \).</param>
 <returns>The tensor corresponding to \( \frac{\partial y}{\partial a} = \frac{\partial y}{\partial f(a, b)} \frac{\partial f(a, b)}{\partial a} \).</returns>
</member>
<member name="M:DiffSharp.BinaryOp.fRaw(DiffSharp.Backends.RawTensor,DiffSharp.Backends.RawTensor)">
 <summary>RawTensor operation \( f(a, b) \) performing the op.</summary>
 <param name="a">The first argument \( a \).</param>
 <param name="b">The second argument \( b \).</param>
 <returns>The function's value \( f(a, b) \).</returns>
</member>
<member name="M:DiffSharp.BinaryOp.bd_dfdb(DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Derivative propagation rule for forward differentiation mode for the partial derivative with respect to the second argument of the function. This represents the contribution of the function's second argument \( b \) to the derivative of \( f(a, b) \) with respect a value \( x \) earlier in the computation graph than the function's arguments. In other words, it computes the second term in the right-hand side of the equation \( \frac{\partial f(a, b)}{\partial x} = \frac{\partial a}{\partial x} \frac{\partial f(a, b)}{\partial a} + \frac{\partial b}{\partial x} \frac{\partial f(a, b)}{\partial b} \).</summary>
 <param name="a">The first argument \( a \).</param>
 <param name="b">The second argument \( b \).</param>
 <param name="bd">The second argument's derivative \( \frac{\partial b}{\partial x} \).</param>
 <param name="f">The function's pre-computed primal evaluation result \( f(a, b) \), which can be one of the terms involved in the derivative computation (e.g., the derivative of the exponential function) and be used without the need to recompute it.</param>
 <returns>The tensor corresponding to \( \frac{\partial b}{\partial x} \frac{\partial f(a, b)}{\partial b} \).</returns>
</member>
<member name="M:DiffSharp.BinaryOp.ad_dfda(DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Derivative propagation rule for forward differentiation mode for the partial derivative with respect to the first argument of the function. This represents the contribution of the function's first argument \( a \) to the derivative of \( f(a, b) \) with respect a value \( x \) earlier in the computation graph than the function's arguments. In other words, it computes the first term in the right-hand side of the equation \( \frac{\partial f(a, b)}{\partial x} = \frac{\partial a}{\partial x} \frac{\partial f(a, b)}{\partial a} + \frac{\partial b}{\partial x} \frac{\partial f(a, b)}{\partial b} \).</summary>
 <param name="a">The first argument \( a \).</param>
 <param name="ad">The first argument's derivative \( \frac{\partial a}{\partial x} \).</param>
 <param name="b">The second argument \( b \).</param>
 <param name="f">The function's pre-computed primal evaluation result \( f(a, b) \), which can be one of the terms involved in the derivative computation (e.g., the derivative of the exponential function) and be used without the need to recompute it.</param>
 <returns>The tensor corresponding to \( \frac{\partial a}{\partial x} \frac{\partial f(a, b)}{\partial a} \).</returns>
</member>
<member name="T:DiffSharp.BinaryOp">
 <summary>Defines a new op implementing a binary function and its derivatives. Instances of this class are used with the <see cref="M:DiffSharp.Tensor.Op(DiffSharp.BinaryOp)"/> method to define a new differentiable tensor function that supports forward, reverse, and nested differentiation.</summary>
 <remarks>
 <para>This type represents the most generic definition of a new op representing a binary function, allowing the specification of: (1) the <see cref="T:DiffSharp.Backends.RawTensor"/> operation, (2) the derivative propagation rule for the forward differentiation mode and (3) the derivative propagation rule for the reverse differentiation mode.</para>
 <para>In general, if you are implementing a simple elementwise op, you should prefer using the <see cref="T:DiffSharp.BinaryOpElementwise"/> type, which is much simpler to use.</para>
 </remarks>
 <example>
 <code>
 { new BinaryOp("matmul") with
     member _.fRaw(a,b) = a.MatMulTT(b)
     member _.ad_dfda(a,ad,b,f) = ad.matmul(b)
     member _.bd_dfdb(a,b,bd,f) = a.matmul(bd)
     member _.fd_dfda(a,b,f,fd) = fd.matmul(b.transpose())
     member _.fd_dfdb(a,b,f,fd) = a.transposeExt().matmul(fd)
 }
 </code>
 </example>
</member>
<member name="M:DiffSharp.UnaryOpElementwise.dfda(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Derivative of the function with respect to its argument, \( \frac{\partial f(a)}{\partial a} \).</summary>
 <param name="a">The argument \( a \)</param>
 <param name="f">The function's pre-computed primal evaluation result \( f(a) \), which can be one of the terms involved in the derivative computation (e.g., the derivative of the exponential function) and be used without the need to recompute it.</param>
 <returns>The tensor corresponding to \( \frac{\partial f(a)}{\partial a} \).</returns>
</member>
<member name="T:DiffSharp.UnaryOpElementwise">
 <summary>Defines a new op implementing an elementwise unary function and its derivatives. Instances of this class are used with the <see cref="M:DiffSharp.Tensor.Op(DiffSharp.UnaryOp)"/> method to define a new differentiable tensor function that supports forward, reverse, and nested differentiation.</summary>
 <remarks>
 <para>This type is specialized to elementwise ops. It requires the user to specify only (1) the <see cref="T:DiffSharp.Backends.RawTensor"/> operation and (2) the derivative of the function with respect to its argument. The corresponding derivative propagation rules for the forward and reverse differentiation modes are automatically generated.</para>
 <para>If you are implementing a complex op that is not elementwise, you can use the generic type <see cref="T:DiffSharp.UnaryOp"/>, which allows you to define the full derivative propagation rules.</para>
 </remarks>
 <example>
 <code>
 { new UnaryOpElementwise("cos") with
     member _.fRaw(a) = a.CosT()
     member _.dfda(a,f) = -a.sin()
 }

 { new UnaryOpElementwise("exp") with
     member _.fRaw(a) = a.ExpT()
     member _.dfda(a,f) = f
 }

 { new UnaryOpElementwise("log") with
     member _.fRaw(a) = a.LogT()
     member _.dfda(a,f) = 1/a
 }
 </code>
 </example>
</member>
<member name="P:DiffSharp.UnaryOp.name">
<summary>
 Name of the op.
</summary>
</member>
<member name="M:DiffSharp.UnaryOp.fd_dfda(DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Derivative propagation rule for reverse differentiation mode. This represents the derivative of a value \( y \), which comes later in the computation graph than the function's value \( f(a) \), with respect to the function's argument \( a \). In other words, it computes \( \frac{\partial y}{\partial a} = \frac{\partial y}{\partial f(a)} \frac{\partial f(a)}{\partial a} \).</summary>
 <param name="a">The argument \( a \).</param>
 <param name="f">The function's pre-computed primal evaluation result \( f(a) \), which can be one of the terms involved in the derivative computation (e.g., the derivative of the exponential function) and be used without the need to recompute it.</param>
 <param name="fd">The derivative with respect to the function's output \( \frac{\partial y}{\partial f(a)} \).</param>
 <returns>The tensor corresponding to \( \frac{\partial y}{\partial a} = \frac{\partial y}{\partial f(a)} \frac{\partial f(a)}{\partial a} \).</returns>
</member>
<member name="M:DiffSharp.UnaryOp.fRaw(DiffSharp.Backends.RawTensor)">
 <summary>RawTensor operation \( f(a) \) performing the op.</summary>
 <param name="a">The argument \( a \).</param>
 <returns>The function's value \( f(a) \).</returns>
</member>
<member name="M:DiffSharp.UnaryOp.ad_dfda(DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Derivative propagation rule for forward differentiation mode. This represents the derivative of \( f(a) \) with respect a value \( x \) earlier in the computation graph than the function's argument \( a \). In other words, it computes \( \frac{\partial f(a)}{\partial x} = \frac{\partial a}{\partial x} \frac{\partial f(a)}{\partial a} \).</summary>
 <param name="a">The argument \( a \).</param>
 <param name="ad">The argument's derivative \( \frac{\partial a}{\partial x} \).</param>
 <param name="f">The function's pre-computed primal evaluation result \( f(a) \), which can be one of the terms involved in the derivative computation (e.g., the derivative of the exponential function) and be used without the need to recompute it.</param>
 <returns>The tensor corresponding to \( \frac{\partial f(a)}{\partial x} = \frac{\partial a}{\partial x} \frac{\partial f(a)}{\partial a} \).</returns>
</member>
<member name="T:DiffSharp.UnaryOp">
 <summary>Defines a new op implementing a unary function and its derivatives. Instances of this class are used with the <see cref="M:DiffSharp.Tensor.Op(DiffSharp.UnaryOp)"/> method to define a new differentiable tensor function that supports forward, reverse, and nested differentiation.</summary>
 <remarks>
 <para>This type represents the most generic definition of a new op representing a unary function, allowing the specification of: (1) the <see cref="T:DiffSharp.Backends.RawTensor"/> operation, (2) the derivative propagation rule for the forward differentiation mode and (3) the derivative propagation rule for the reverse differentiation mode.</para>
 <para>In general, if you are implementing a simple elementwise op, you should prefer using the <see cref="T:DiffSharp.UnaryOpElementwise"/> type, which is much simpler to use.</para>
 </remarks>
 <example>
 <code>
 { new UnaryOp("transpose") with
     member _.fRaw(a) = a.TransposeT2()
     member _.ad_dfda(a,ad,f) = ad.transpose()
     member _.fd_dfda(a,f,fd) = fd.transpose()
 }
 </code>
 </example>
</member>
<member name="M:DiffSharp.Tensor.zerosLike(Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a new tensor filled with &apos;0&apos; values for the given shape, element type and configuration, defaulting to the 
 shape and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.zeroLike(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a scalar &apos;0&apos; tensor for the given element type and configuration, defaulting to
 the element type and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.viewAs(DiffSharp.Tensor)">
 <summary>View this tensor as the same size as other.</summary>
 <remarks>The returned tensor shares the same data and must have the same number of elements, but may have a different size. For a tensor to be viewed, the new view size must be compatible with its original size.
   The returned tensor shares the same data and must have the same number of elements, but may have a different size. 
   For a tensor to be viewed, the new view size must be compatible with its original size and stride, i.e., each new view dimension must either be a subspace of an original dimension,
   or only span across original dimensions \(d, d+1, \dots, d+kd,d+1,…,d+k\) that satisfy the following contiguity-like condition that
   \(\forall i = d, \dots, d+k-1∀i=d,…,d+k−1 ,\) \[\text{stride}[i] = \text{stride}[i+1] \times \text{size}[i+1]\]
 </remarks>
 <param name="other">The result tensor has the same size as other.</param>
</member>
<member name="M:DiffSharp.Tensor.view(System.Int32)">
 <summary>Returns a new tensor with the same data as the object tensor but of a different shape.</summary>
 <remarks>
   The returned tensor shares the same data and must have the same number of elements, but may have a different size. 
   For a tensor to be viewed, the new view size must be compatible with its original size and stride, i.e., each new view dimension must either be a subspace of an original dimension,
   or only span across original dimensions \(d, d+1, \dots, d+kd,d+1,…,d+k\) that satisfy the following contiguity-like condition that
   \(\forall i = d, \dots, d+k-1∀i=d,…,d+k−1 ,\) \[\text{stride}[i] = \text{stride}[i+1] \times \text{size}[i+1]\]
 </remarks>
 <param name="shape">the desired shape</param>
</member>
<member name="M:DiffSharp.Tensor.view(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Returns a new tensor with the same data as the self tensor but of a different shape.</summary>
 <remarks>
   The returned tensor shares the same data and must have the same number of elements, but may have a different size. 
   For a tensor to be viewed, the new view size must be compatible with its original size and stride, i.e., each new view dimension must either be a subspace of an original dimension,
   or only span across original dimensions \(d, d+1, \dots, d+kd,d+1,…,d+k\) that satisfy the following contiguity-like condition that
   \(\forall i = d, \dots, d+k-1∀i=d,…,d+k−1 ,\) \[\text{stride}[i] = \text{stride}[i+1] \times \text{size}[i+1]\]
 </remarks>
 <param name="shape">The desired shape of returned tensor.</param>
</member>
<member name="M:DiffSharp.Tensor.var(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the variance of each row of the input tensor in the given dimension dim.</summary>
 <remarks>
   <para>If keepdim is True, the output tensor is of the same size as input except in the dimension dim where it is of size 1. Otherwise, dim is squeezed, resulting in the output tensor having 1 fewer dimension(s).</para>
   <para>If unbiased is False, then the variance will be calculated via the biased estimator. Otherwise, Bessel’s correction will be used.</para>
 </remarks>
 <param name="dim">The dimension to reduce.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
 <param name="unbiased">Whether to use the unbiased estimation or not.</param>
</member>
<member name="M:DiffSharp.Tensor.var(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the variance of all elements in the input tensor.</summary>
 <remarks>If unbiased is False, then the variance will be calculated via the biased estimator. Otherwise, Bessel’s correction will be used.</remarks>
 <param name="unbiased">Whether to use the unbiased estimation or not.</param>
</member>
<member name="M:DiffSharp.Tensor.unstack(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Removes a tensor dimension.</summary>
 <param name="dim">The dimension to remove, defaults to 0.</param>
 <returns>Returns an array of all slices along a given dimension.</returns>
</member>
<member name="M:DiffSharp.Tensor.unsqueezeAs(DiffSharp.Tensor)">
 <summary>Returns a new tensor with dimensions of size one appended to the end until the number of dimensions is the same as the other tensor.</summary>
 <param name="other">The other tensor.</param>
</member>
<member name="M:DiffSharp.Tensor.unsqueeze(System.Int32)">
 <summary>Returns a new tensor with a dimension of size one inserted at the specified position</summary>
 <param name="dim">The index at which to insert the singleton dimension.</param>
</member>
<member name="M:DiffSharp.Tensor.unflatten(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Unflattens a tensor dimension by expanding it to the given shape.</summary>
 <param name="dim">The dimension to unflatten.</param>
 <param name="unflattenedShape">New shape of the unflattened dimenension.</param>
</member>
<member name="M:DiffSharp.Tensor.undilate(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Reverse the dilation of the tensor in using the given dilations in each corresponding dimension.</summary>
 <param name="dilations">The dilations to use.</param>
</member>
<member name="M:DiffSharp.Tensor.transpose">
 <summary>Returns a tensor that is a transposed version of input with dimensions 0 and 1 swapped.</summary>
</member>
<member name="M:DiffSharp.Tensor.transpose(System.Int32,System.Int32)">
 <summary>Returns a tensor that is a transposed version of input. The given dimensions dim0 and dim1 are swapped.</summary>
 <param name="dim0">The first dimension to be transposed.</param>
 <param name="dim1">The second dimension to be transposed.</param>
</member>
<member name="M:DiffSharp.Tensor.trace">
 <summary>Returns the sum of the elements of the diagonal of the input 2-D matrix.</summary>
</member>
<member name="M:DiffSharp.Tensor.toSingle">
<summary>
 Convert a scalar tensor to a float32 value
</summary>
</member>
<member name="M:DiffSharp.Tensor.toScalar">
<summary>
 Returns the value of a scalar tensor as an object
</summary>
</member>
<member name="M:DiffSharp.Tensor.toSByte">
<summary>
 Convert a scalar tensor to a signed byte value
</summary>
</member>
<member name="M:DiffSharp.Tensor.toInt64">
<summary>
 Convert a scalar tensor to an int64 value
</summary>
</member>
<member name="M:DiffSharp.Tensor.toInt32">
<summary>
 Convert a scalar tensor to an int32 value
</summary>
</member>
<member name="M:DiffSharp.Tensor.toInt16">
<summary>
 Convert a scalar tensor to an int16 value
</summary>
</member>
<member name="M:DiffSharp.Tensor.toImageString(Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>Convert tensor to a grayscale image tensor and return a string representation approximating grayscale values</summary>
</member>
<member name="M:DiffSharp.Tensor.toImage(Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Convert tensor to an image tensor with shape Channels x Height x Width</summary>
</member>
<member name="M:DiffSharp.Tensor.toDouble">
<summary>
 Convert a scalar tensor to a float64 value
</summary>
</member>
<member name="M:DiffSharp.Tensor.toByte">
<summary>
 Convert a scalar tensor to a byte value
</summary>
</member>
<member name="M:DiffSharp.Tensor.toBool">
<summary>
 Convert a scalar tensor to a boolean value
</summary>
</member>
<member name="M:DiffSharp.Tensor.toArray6D``1">
<summary>
 Returns the value of a 6D tensor as a 6D array
</summary>
</member>
<member name="M:DiffSharp.Tensor.toArray5D``1">
<summary>
 Returns the value of a 5D tensor as a 5D array
</summary>
</member>
<member name="M:DiffSharp.Tensor.toArray4D``1">
<summary>
 Returns the value of a 4D tensor as a 4D array
</summary>
</member>
<member name="M:DiffSharp.Tensor.toArray3D``1">
<summary>
 Returns the value of a 3D tensor as a 3D array
</summary>
</member>
<member name="M:DiffSharp.Tensor.toArray2D``1">
<summary>
 Returns the value of a 2D tensor as a 2D array
</summary>
</member>
<member name="M:DiffSharp.Tensor.toArray1D``1">
<summary>
 Returns the value of a 1D tensor as a 1D array
</summary>
</member>
<member name="M:DiffSharp.Tensor.toArray">
<summary>
 Returns the value of a (non-scalar) tensor as an array
</summary>
</member>
<member name="M:DiffSharp.Tensor.tanh">
 <summary>Returns a new tensor with the hyperbolic tangent of the elements of input.</summary>
</member>
<member name="M:DiffSharp.Tensor.tan">
 <summary>Returns a new tensor with the tangent of the elements of input</summary>
</member>
<member name="M:DiffSharp.Tensor.summary">
<summary>
 Returns a string summarising the tensor
</summary>
</member>
<member name="M:DiffSharp.Tensor.sumToSize(System.Int32[],Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype})">
 <summary>Sum this tensor to size <paramref name="newShape" />, which must be broadcastable to this tensor size.</summary>
</member>
<member name="M:DiffSharp.Tensor.sum(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype})">
 <summary>Returns the sum of each row of the input tensor in the given dimension dim. If dim is a list of dimensions, reduce over all of them.</summary>
 <remarks>If keepdim is <c>true</c>, the output tensor is of the same size as input except in the dimension dim where it is of size 1. Otherwise, dim is squeezed, resulting in the output tensor having 1 fewer dimension.</remarks>
 <param name="dim">The dimension to reduce.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
 <param name="dtype">The desired data type of returned tensor.</param>
</member>
<member name="M:DiffSharp.Tensor.sum(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype})">
 <summary>Returns the sum of all elements in the input tensor.</summary>
 <param name="dtype">The desired data type of returned tensor.</param>
</member>
<member name="M:DiffSharp.Tensor.sub(System.IConvertible)">
 <summary>Subtracts the scalar <paramref name="b" /> from the corresponding element of the object tensor. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.sub(DiffSharp.Tensor)">
 <summary>Subtracts each element of the object tensor from the corresponding element of the self tensor. The resulting tensor is returned.</summary>
 <remarks>The shapes of the two tensors must be broadcastable.</remarks>
</member>
<member name="M:DiffSharp.Tensor.std(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the standard deviation of all elements in the input tensor.</summary>
 <remarks>If unbiased is False, then the standard deviation will be calculated via the biased estimator. Otherwise, Bessel’s correction will be used.</remarks>
 <param name="unbiased">Whether to use the unbiased estimation or not.</param>
</member>
<member name="M:DiffSharp.Tensor.std(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the standard deviation of each row of the input tensor in the given dimension dim.</summary>
 <remarks>
   <para>If keepdim is True, the output tensor is of the same size as input except in the dimension dim where it is of size 1. Otherwise, dim is squeezed, resulting in the output tensor having 1 fewer dimension(s).</para>
   <para>If unbiased is False, then the standard deviation will be calculated via the biased estimator. Otherwise, Bessel’s correction will be used.</para>
 </remarks>
 <param name="dim">The dimension to reduce.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
 <param name="unbiased">Whether to use the unbiased estimation or not.</param>
</member>
<member name="M:DiffSharp.Tensor.standardize">
<summary>
 Returns the tensor after standardization (z-score normalization)
</summary>
</member>
<member name="M:DiffSharp.Tensor.stack(System.Collections.Generic.IEnumerable{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Concatenates sequence of tensors along a new dimension.</summary>
 <remarks>All tensors need to be of the same shape.</remarks>
 <param name="tensors">sequence of tensors to concatenate</param>
 <param name="dim">dimension to insert. Has to be between 0 and the number of dimensions of concatenated tensors (inclusive)</param>
</member>
<member name="M:DiffSharp.Tensor.squeeze(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Returns a tensor with all the dimensions of input of size 1 removed.</summary>
 <remarks>If the tensor has a batch dimension of size 1, then squeeze(input) will also remove the batch dimension, which can lead to unexpected errors.</remarks>
 <param name="dim">If given, the input will be squeezed only in this dimension.</param>
</member>
<member name="M:DiffSharp.Tensor.sqrt">
 <summary>Returns a new tensor with the square-root of the elements of input.</summary>
</member>
<member name="M:DiffSharp.Tensor.split(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Splits the tensor into chunks. Each chunk is a view of the original tensor.</summary>
 <param name="sizes">List of sizes for each chunk</param>
 <param name="dim">The dimension along which to split the tensor, defaults to 0.</param>
</member>
<member name="M:DiffSharp.Tensor.softplus">
 <summary>Applies the softplus function element-wise.</summary>
 <remarks>\[\text{softplus}(x) = \frac{1}{\beta} * \log(1 + \exp(\beta * x))\]</remarks>
</member>
<member name="M:DiffSharp.Tensor.softmax(System.Int32)">
 <summary>Applies a softmax function.</summary>
 <remarks>Softmax is defined as: \text{softmax}(x_{i}) = \frac{\exp(x_i)}{\sum_j \exp(x_j)}.</remarks>
 <param name="dim">A dimension along which softmax will be computed.</param>
</member>
<member name="M:DiffSharp.Tensor.sinh">
 <summary>Returns a new tensor with the hyperbolic sine of the elements of input.</summary>
</member>
<member name="M:DiffSharp.Tensor.sin">
 <summary>Returns a new tensor with the sine of the elements of input</summary>
</member>
<member name="M:DiffSharp.Tensor.sign">
 <summary>Returns a new tensor with the signs of the elements of input.</summary>
 <remarks>The tensor will have the same element type as the input tensor.</remarks>
</member>
<member name="M:DiffSharp.Tensor.sigmoid">
 <summary>Applies the sigmoid element-wise function</summary>
 <remarks>\[\text{sigmoid}(x) = \frac{1}{1 + \exp(-x)}\]</remarks>
</member>
<member name="P:DiffSharp.Tensor.fanout(System.UInt32)">
<summary>
 Gets the fanout of a tensor used in reverse-mode differentiation
</summary>
</member>
<member name="P:DiffSharp.Tensor.derivative(DiffSharp.Tensor)">
<summary>
 Gets or sets the derivative of a tensor used in differentiation
</summary>
</member>
<member name="M:DiffSharp.Tensor.scatter(System.Int32,DiffSharp.Tensor,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Scatter values along an axis specified by dim.</summary>
 <param name="dim">The axis along which to index.</param>
 <param name="indices">The the indices of elements to gather.</param>
 <param name="destinationShape">The destination shape.</param>
</member>
<member name="M:DiffSharp.Tensor.scalarLike(System.IConvertible,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a new scalar tensor for the given shape, element type and configuration, defaulting to the 
 shape and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.save(System.String)">
 <summary>Saves the tensor to the given file using a bespoke binary format.</summary>
 <remarks>
   The binary format records the elements, backend, element type and shape. It does not record the device.
   The format used may change from version to version of DiffSharp.
 </remarks>
</member>
<member name="M:DiffSharp.Tensor.safelog(Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>Returns the logarithm of the tensor after clamping the tensor so that all its elements are greater than epsilon. This is to avoid a -inf result for elements equal to zero.</summary>
</member>
<member name="M:DiffSharp.Tensor.round">
 <summary>Returns a new tensor with each of the elements of input rounded to the closest integer.</summary>
 <remarks>The tensor will have the same element type as the input tensor.</remarks>
</member>
<member name="M:DiffSharp.Tensor.reverseReset(System.Boolean)">
 <summary>Reset the reverse mode computation graph associated with the given output tensor.</summary>
</member>
<member name="M:DiffSharp.Tensor.reversePush(DiffSharp.Tensor)">
 <summary>Push the given value as part of the reverse-mode computation at the given output tensor.</summary>
 <param name="value">The value to apply.</param>
</member>
<member name="M:DiffSharp.Tensor.reverseDiff(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.UInt32})">
 <summary>
  Returns the input tensor with added support for reverse-mode automatic differentiation.
 </summary>
 <param name="derivative">The derivative (adjoint) to assign to the new reverse-mode tensor. Defaults to an empty placeholder tensor.</param>
 <param name="nestingTag">The level nestingTag for nested differentiation. Defaults to the current global nesting level</param>
 <remarks>
  Any tensors produced using this tensor will also support reverse-mode propagation. After the completion
  of the corresponding <c>reverse</c> operation on the overall result tensor, the computed derivative
  will be available. 
 </remarks>
</member>
<member name="M:DiffSharp.Tensor.reverse(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Propagate the reverse-mode derivative backwards in the computation graph, starting from this tensor.</summary>
 <param name="value">The derivative value to propagate backwards. Should have the same shape with this tensor.</param>
 <param name="zeroDerivatives">Indicates whether any existing derivatives in the computation graph (for example from a previous reverse propagation that was executed) should be zeroed or not before starting this propagation. Default: true</param>
</member>
<member name="M:DiffSharp.Tensor.repeat(System.Int32,System.Int32)">
 <summary>Repeat elements of a tensor</summary>
 <param name="dim">The dimension along which to repeat values.</param>
 <param name="times">The number of repetitions for each element.</param>
</member>
<member name="M:DiffSharp.Tensor.relu">
 <summary>Applies the rectified linear unit function element-wise.</summary>
</member>
<member name="M:DiffSharp.Tensor.randnLike(Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a new tensor with random values drawn from the standard normal distribution, for the
 given shape, element type and configuration, defaulting to the shape and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.randintLike(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a new tensor with random integer values drawn from the given range, for the
 given shape, element type and configuration, defaulting to the shape and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.randLike(Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a new tensor with random values drawn from the uniform distribution [0,1) for the
 given shape, element type and configuration, defaulting to the shape and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.pow(System.IConvertible)">
 <summary>Raises each element of the self tensor to the power of the scalar <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.pow(DiffSharp.Tensor)">
 <summary>Raises each element of the self tensor to the power of each corresponding element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
 <remarks>The shapes of the two tensors must be broadcastable.</remarks>
</member>
<member name="M:DiffSharp.Tensor.permute(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Returns the original tensor with its dimensions permuted.</summary>
 <param name="permutation">The desired ordering of dimensions.</param>
</member>
<member name="M:DiffSharp.Tensor.pad(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Add zero padding to each side of a tensor</summary>
 <param name="paddings">The implicit paddings on corresponding sides of the input.</param>
</member>
<member name="M:DiffSharp.Tensor.op_UnaryNegation(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the negative of the elements of <paramref name="a" />.</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Subtraction(System.IConvertible,DiffSharp.Tensor)">
 <summary>Subtracts each element of the tensore <paramref name="b" /> from the scalar <paramref name="a" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Subtraction(DiffSharp.Tensor,System.IConvertible)">
 <summary>Subtracts the scalar <paramref name="b" /> from the corresponding element of the tensor <paramref name="a" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Subtraction(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Subtracts each element of the tensor <paramref name="b" /> from the corresponding element of the tensor <paramref name="a" />. The resulting tensor is returned.</summary>
 <remarks>The shapes of the two tensors must be broadcastable.</remarks>
</member>
<member name="M:DiffSharp.Tensor.op_Multiply(System.IConvertible,DiffSharp.Tensor)">
 <summary>Multiplies the scalar <paramref name="a" /> by each element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Multiply(DiffSharp.Tensor,System.IConvertible)">
 <summary>Multiplies each element of the tensor <paramref name="a" /> by the scalar <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Multiply(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Multiplies each element of the tensor <paramref name="a" /> by the corresponding element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
 <remarks>The shapes of the two tensors must be broadcastable.</remarks>
</member>
<member name="M:DiffSharp.Tensor.op_MinusMinusGreater``1(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,``0})">
 <summary>Pipeline the tensor into a function.</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Explicit(DiffSharp.Tensor)">
<summary>
 Convert a scalar tensor to a boolean value
</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Explicit(DiffSharp.Tensor)">
<summary>
 Convert a scalar tensor to an int64 value
</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Explicit(DiffSharp.Tensor)">
<summary>
 Convert a scalar tensor to an int32 value
</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Explicit(DiffSharp.Tensor)">
<summary>
 Convert a scalar tensor to an int16 value
</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Explicit(DiffSharp.Tensor)">
<summary>
 Convert a scalar tensor to a signed byte value
</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Explicit(DiffSharp.Tensor)">
<summary>
 Convert a scalar tensor to a byte value
</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Explicit(DiffSharp.Tensor)">
<summary>
 Convert a scalar tensor to a float64 value
</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Explicit(DiffSharp.Tensor)">
<summary>
 Convert a scalar tensor to a float32 value
</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Division(System.IConvertible,DiffSharp.Tensor)">
 <summary>Divides the scalar <paramref name="a" /> by the each element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Division(DiffSharp.Tensor,System.IConvertible)">
 <summary>Divides each element of the tensor <paramref name="a" /> by the scalar <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Division(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Divides each element of the tensor <paramref name="a" /> by the corresponding element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
 <remarks>The shapes of the two tensors must be broadcastable.</remarks>
</member>
<member name="M:DiffSharp.Tensor.op_Addition(System.IConvertible,DiffSharp.Tensor)">
 <summary>The scalar <paramref name="a" /> is added to each element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Addition(DiffSharp.Tensor,System.IConvertible)">
 <summary>Each element of the tensor <paramref name="a" /> is added to the scalar <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.op_Addition(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Each element of the tensor <paramref name="a" /> is added to each corresponding element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
 <remarks>The shapes of the two tensors must be broadcastable.</remarks>
</member>
<member name="M:DiffSharp.Tensor.onesLike(Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a new tensor filled with &apos;1&apos; values for the given shape, element type and configuration, defaulting to the 
 shape and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.onehotLike(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a tensor in the manner of &lt;see cref=&quot;M:DiffSharp.dsharp.onehot&quot;/&gt; for the given element type and configuration, defaulting to
 the element type and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.oneLike(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a scalar &apos;1&apos; tensor for the given element type and configuration, defaulting to
 the element type and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.ofRawTensor(DiffSharp.Backends.RawTensor)">
 <summary>
 Creates a new tensor from the raw tensor.
 </summary>
 <param name="rawTensor">The given raw tensor.</param>
</member>
<member name="M:DiffSharp.Tensor.normalize">
<summary>
 Returns the tensor after min-max scaling
</summary>
</member>
<member name="M:DiffSharp.Tensor.noDiff">
<summary>
  Returns the input tensor but with any support for automatic differentiation removed.
</summary>
</member>
<member name="M:DiffSharp.Tensor.nllLoss(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>The negative log likelihood loss.</summary>
 <param name="target">The target tensor.</param>
 <param name="weight">A optional manual rescaling weight given to the loss of each batch element.</param>
 <param name="reduction">Optionally specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: size_average and reduce are in the process of being deprecated, and in the meantime, specifying either of those two args will override reduction. Default: 'mean'.</param>
</member>
<member name="M:DiffSharp.Tensor.neg">
 <summary>Returns a new tensor with the negative of the elements of the object tensor.</summary>
</member>
<member name="M:DiffSharp.Tensor.ne(DiffSharp.Tensor)">
 <summary>Computes element-wise \(a \neq b\), returning a boolean tensor containing a <c>true</c> at each location where the comparison is true</summary>
</member>
<member name="M:DiffSharp.Tensor.multinomial(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a tensor where each row contains numSamples indices sampled from the multinomial probability distribution located in the corresponding row of tensor input.</summary>
 <param name="numSamples">The number of samples to draw.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
 <param name="normalize">Indicates where the probabilities should first be normalized by their sum.</param>
</member>
<member name="M:DiffSharp.Tensor.mul(System.IConvertible)">
 <summary>Multiplies each element of the object tensor by the scalar <paramref name="b" />. The resulting tensor is returned.</summary>
 <remarks>The shapes of the two tensors must be broadcastable.</remarks>
</member>
<member name="M:DiffSharp.Tensor.mul(DiffSharp.Tensor)">
 <summary>Multiplies each element of the object tensor by the corresponding element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
 <remarks>The shapes of the two tensors must be broadcastable.</remarks>
</member>
<member name="M:DiffSharp.Tensor.mseLoss(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>Creates a criterion that measures the mean squared error (squared L2 norm) between each element in the input and the target.</summary>
 <param name="target">The target tensor.</param>
 <param name="reduction">Optionally specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: size_average and reduce are in the process of being deprecated, and in the meantime, specifying either of those two args will override reduction. Default: 'mean'.</param>
</member>
<member name="M:DiffSharp.Tensor.move(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a new tensor with the same contents moved to the given configuration
</summary>
</member>
<member name="M:DiffSharp.Tensor.move(DiffSharp.Device)">
<summary>
 Returns a new tensor with the same contents moved to the given device
</summary>
</member>
<member name="M:DiffSharp.Tensor.move(DiffSharp.Backend)">
<summary>
 Returns a new tensor with the same contents moved to the given backend
</summary>
</member>
<member name="M:DiffSharp.Tensor.min(DiffSharp.Tensor)">
<summary>
 Returns the element-wise minimum of the elements in the two tensors.
</summary>
</member>
<member name="M:DiffSharp.Tensor.min">
<summary>
 Returns the minimum value of all elements in the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.min(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Returns the minimum value along the given dimension of all elements in the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.mean(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the mean value of each row of the input tensor in the given dimension dim.</summary>
 <remarks>If keepdim is True, the output tensor is of the same size as input except in the dimension dim where it is of size 1. Otherwise, dim is squeezed, resulting in the output tensor having 1 fewer dimension.</remarks>
 <param name="dim">The dimension to reduce.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
</member>
<member name="M:DiffSharp.Tensor.mean">
 <summary>Returns the mean value of all elements in the input tensor</summary>
</member>
<member name="M:DiffSharp.Tensor.maxunpool3d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Computes a partial inverse of maxpool3di</summary>
 <param name="indices">The indices selected by maxpool3di.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSizes.</param>
 <param name="paddings">The implicit zero paddings to be added on corresponding sides.</param>
 <param name="outputSize">The targeted output size.</param>
</member>
<member name="M:DiffSharp.Tensor.maxunpool2d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Computes a partial inverse of maxpool2di</summary>
 <param name="indices">The indices selected by maxpool2di.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSizes.</param>
 <param name="paddings">The implicit zero paddings to be added on corresponding sides.</param>
 <param name="outputSize">The targeted output size.</param>
</member>
<member name="M:DiffSharp.Tensor.maxunpool1d(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Computes a partial inverse of maxpool1di</summary>
 <param name="indices">The indices selected by maxpool1di.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="outputSize">The targeted output size.</param>
</member>
<member name="M:DiffSharp.Tensor.maxpool3di(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 3D max pooling over an input signal composed of several input planes, returning the max indices along with the outputs.</summary>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSize.</param>
 <param name="paddings">The implicit zero paddings to be added on corresponding sides.</param>
</member>
<member name="M:DiffSharp.Tensor.maxpool3d(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 3D max pooling over an input signal composed of several input planes.</summary>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSizes.</param>
 <param name="paddings">The implicit zero paddings to be added on corresponding sides.</param>
</member>
<member name="M:DiffSharp.Tensor.maxpool2di(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 2D max pooling over an input signal composed of several input planes, returning the max indices along with the outputs.</summary>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSize.</param>
 <param name="paddings">The implicit zero paddings to be added on corresponding sides.</param>
</member>
<member name="M:DiffSharp.Tensor.maxpool2d(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 2D max pooling over an input signal composed of several input planes.</summary>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSize.</param>
 <param name="paddings">The implicit zero paddings to be added on corresponding sides.</param>
</member>
<member name="M:DiffSharp.Tensor.maxpool1di(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Applies a 1D max pooling over an input signal composed of several input planes, returning the max indices along with the outputs.</summary>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
</member>
<member name="M:DiffSharp.Tensor.maxpool1d(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Applies a 1D max pooling over an input signal composed of several input planes.</summary>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
</member>
<member name="M:DiffSharp.Tensor.max(DiffSharp.Tensor)">
<summary>
 Returns the element-wise maximum of the elements in the two tensors.
</summary>
</member>
<member name="M:DiffSharp.Tensor.max">
<summary>
 Returns the maximum value of all elements in the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.max(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Returns the maximum value along the given dimension of all elements in the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.matmul(DiffSharp.Tensor)">
 <summary>Matrix product of two tensors.</summary>

 <remarks>
 <para>
 The behavior depends on the dimensionality of the tensors as follows:
 </para>
 
 <para>
 If both tensors are 1-dimensional, the dot product (scalar) is returned.
 </para>
 
 <para>
 If both arguments are 2-dimensional, the matrix-matrix product is returned.
 </para>
 
 <para>
 If the first argument is 1-dimensional and the second argument is 2-dimensional, a 1 is prepended to its dimension for the purpose of the matrix multiply. After the matrix multiply, the prepended dimension is removed.
 </para>
 
 <para>
  If the first argument is 2-dimensional and the second argument is 1-dimensional, the matrix-vector product is returned.
 </para>
 
 <para>
  If both arguments are at least 1-dimensional and at least one argument is N-dimensional (where N > 2), then a 
  batched matrix multiply is returned. If the first argument is 1-dimensional, a 1 is prepended to its dimension for the
  purpose of the batched matrix multiply and removed after. If the second argument is 1-dimensional, a 1 is appended to
  its dimension for the purpose of the batched matrix multiple and removed after. The non-matrix (i.e. batch) dimensions
  are broadcasted (and thus must be broadcastable). For example, if input is a (j \times 1 \times n \times m)(j×1×n×m)
  tensor and other is a (k \times m \times p)(k×m×p) tensor, out will be an (j \times k \times n \times p)(j×k×n×p)
  tensor.
 </para>
 </remarks>
</member>
<member name="M:DiffSharp.Tensor.lt(DiffSharp.Tensor)">
 <summary>Computes element-wise \(a &lt; b\), returning a boolean tensor containing a <c>true</c> at each location where the comparison is true</summary>
</member>
<member name="M:DiffSharp.Tensor.logsumexp(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Applies a logsumexp.</summary>
 <param name="dim">The dimension to reduce.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
</member>
<member name="M:DiffSharp.Tensor.logspaceLike(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a tensor in the manner of &lt;see cref=&quot;M:DiffSharp.dsharp.logspace&quot;/&gt; for the given element type and configuration, defaulting to
 the element type and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.logspaceLike(System.Double,System.Double,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a tensor in the manner of &lt;see cref=&quot;M:DiffSharp.dsharp.logspace&quot;/&gt; for the given element type and configuration, defaulting to
 the element type and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.logsoftmax(System.Int32)">
 <summary>Applies a softmax followed by a logarithm.</summary>
 <param name="dim">A dimension along which softmax will be computed.</param>
</member>
<member name="M:DiffSharp.Tensor.log10">
 <summary>Returns a new tensor with the logarithm to the base 10 of the elements of input.</summary>
 <remarks>\[y_{i} = \log_{10} (x_{i})\]</remarks>
</member>
<member name="M:DiffSharp.Tensor.log">
 <summary>Returns a new tensor with the natural logarithm of the elements of input.</summary>
 <remarks> \[y_{i} = \log_{e} (x_{i})\]</remarks>
</member>
<member name="M:DiffSharp.Tensor.load(System.String,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Loads the tensor from the given file using the given element type and configuration.</summary>

 <param name="fileName">The file from which to load the tensor.</param>
 <param name="device">The device of the resulting tensor. Defaults to the current default device.</param>
 <param name="dtype">The element type of the resulting tensor. Defaults to the element type of the saved tensor.</param>
 <param name="backend">The device of the resulting tensor. Defaults to the current default backend.</param>

 <remarks>
    The backend at the time of saving the tensor must be available when the tensor is reloaded.
    The tensor is first loaded into that backend and then moved. As a result, intermediate tensors may be created
    in the process of reloading.
 </remarks>
</member>
<member name="M:DiffSharp.Tensor.linspaceLike(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a tensor in the manner of &lt;see cref=&quot;M:DiffSharp.dsharp.linspace&quot;/&gt; for the given element type and configuration, defaulting to
 the element type and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.linspaceLike(System.Double,System.Double,System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a tensor in the manner of &lt;see cref=&quot;M:DiffSharp.dsharp.linspace&quot;/&gt; for the given element type and configuration, defaulting to
 the element type and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.like(System.Object,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>
  Returns a tensor from the .NET data in <c>value</c> for the given element type and configuration, defaulting to
  the element type and configuration of the input tensor.
 </summary>
</member>
<member name="M:DiffSharp.Tensor.leakyRelu(Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>Applies the leaky rectified linear unit function element-wise</summary>
 <remarks>\[\text{leakyRelu}(x) = \max(0, x) + \text{negativeSlope} * \min(0, x)\]</remarks>
 <param name="negativeSlope">Controls the angle of the negative slope. Default: 0.01.</param>
</member>
<member name="M:DiffSharp.Tensor.le(DiffSharp.Tensor)">
 <summary>Computes element-wise \(a \leq b\), returning a boolean tensor containing a <c>true</c> at each location where the comparison is true</summary>
</member>
<member name="M:DiffSharp.Tensor.isnan">
 <summary>Returns a new tensor with boolean elements representing if each element is NaN or not. Complex values are considered NaN when either their real and/or imaginary part is NaN.</summary>
</member>
<member name="M:DiffSharp.Tensor.isinf">
 <summary>Returns a new tensor with boolean elements representing if each element is +/-INF or not.</summary>
</member>
<member name="M:DiffSharp.Tensor.isSameDiffType(DiffSharp.Tensor)">
<summary>
 Indicates if two tensors have the same differentiation type
</summary>
</member>
<member name="M:DiffSharp.Tensor.int8">
<summary>
 Returns a new tensor with each element converted to type int8
</summary>
</member>
<member name="M:DiffSharp.Tensor.int64">
<summary>
 Returns a new tensor with each element converted to type int64
</summary>
</member>
<member name="M:DiffSharp.Tensor.int32">
<summary>
 Returns a new tensor with each element converted to type int32
</summary>
</member>
<member name="M:DiffSharp.Tensor.int16">
<summary>
 Returns a new tensor with each element converted to type int16
</summary>
</member>
<member name="M:DiffSharp.Tensor.int">
<summary>
 Returns a new tensor with each element converted to type int32
</summary>
</member>
<member name="M:DiffSharp.Tensor.hasnan">
<summary>
 Gets if any value in the tensor is NaN.
</summary>
</member>
<member name="M:DiffSharp.Tensor.hasinfnan">
<summary>
 Gets if any value in the tensor is NaN or +/- INF.
</summary>
</member>
<member name="M:DiffSharp.Tensor.hasinf">
<summary>
 Gets if any value in the tensor is +/- INF.
</summary>
</member>
<member name="M:DiffSharp.Tensor.gt(DiffSharp.Tensor)">
 <summary>Computes element-wise \(a &gt; b\), returning a boolean tensor containing a <c>true</c> at each location where the comparison is true</summary>
</member>
<member name="M:DiffSharp.Tensor.gpu">
<summary>
 Returns a new tensor with the same contents moved to the primary GPU device
</summary>
</member>
<member name="P:DiffSharp.Tensor.shape">
<summary>
 Gets the shape of the tensor
</summary>
</member>
<member name="P:DiffSharp.Tensor.primalRaw">
<summary>
 Gets the raw value of the tensor ignoring all its derivatives
</summary>
</member>
<member name="P:DiffSharp.Tensor.primalDeep">
<summary>
 Gets the value of the tensor ignoring all its derivatives
</summary>
</member>
<member name="P:DiffSharp.Tensor.primal">
<summary>
 Gets the value of the tensor ignoring its first derivative
</summary>
</member>
<member name="P:DiffSharp.Tensor.parentOp">
<summary>
 Gets the parent operation of a tensor used in reverse-mode differentiation
</summary>
</member>
<member name="P:DiffSharp.Tensor.nestingTag">
<summary>
 Gets the differentiation nesting tag of the tensor
</summary>
</member>
<member name="P:DiffSharp.Tensor.nelement">
<summary>
 Gets the number of elements in the tensor
</summary>
</member>
<member name="P:DiffSharp.Tensor.memorySize">
<summary>
 Returns the size in bytes of the total memory used by this tensor. Depending on dtype, backend configuration, this is not guaranteed to be correct and can behave differently in different runtime environments.
</summary>
</member>
<member name="P:DiffSharp.Tensor.isReverseDiff">
<summary>
 Indicates if a tensor is taking part in reverse-mode differentiation
</summary>
</member>
<member name="P:DiffSharp.Tensor.isNoDiff">
<summary>
 Indicates if a tensor is a constant, meaning that it is not taking part in forward or reverse-mode differentiation
</summary>
</member>
<member name="P:DiffSharp.Tensor.isForwardDiff">
<summary>
 Indicates if a tensor is taking part in forward-mode differentiation
</summary>
</member>
<member name="P:DiffSharp.Tensor.fanout">
<summary>
 Gets the fanout of a tensor used in reverse-mode differentiation
</summary>
</member>
<member name="P:DiffSharp.Tensor.elementSize">
<summary>
 Returns the size in bytes of an individual element in this tensor. Depending on dtype, backend configuration, this is not guaranteed to be correct and can behave differently in different runtime environments.
</summary>
</member>
<member name="P:DiffSharp.Tensor.dtype">
<summary>
 Gets the element type of the tensor
</summary>
</member>
<member name="P:DiffSharp.Tensor.dim">
<summary>
 Gets the number of dimensions of the tensor
</summary>
</member>
<member name="P:DiffSharp.Tensor.deviceType">
<summary>
 Gets the device type of the tensor
</summary>
</member>
<member name="P:DiffSharp.Tensor.device">
<summary>
 Gets the device of the tensor
</summary>
</member>
<member name="P:DiffSharp.Tensor.derivative">
<summary>
 Gets or sets the derivative of a tensor used in differentiation
</summary>
</member>
<member name="P:DiffSharp.Tensor.depth">
<summary>
 Gets the differentiation depth of the tensor
</summary>
</member>
<member name="P:DiffSharp.Tensor.backend">
<summary>
 Gets the backend of the tensor
</summary>
</member>
<member name="P:DiffSharp.Tensor.Zero">
<summary>
 Get the scalar zero tensor for the current configuration
</summary>
</member>
<member name="P:DiffSharp.Tensor.One">
<summary>
 Get the scalar one tensor for the current configuration
</summary>
</member>
<member name="P:DiffSharp.Tensor.Item(System.Int32[])">
 <summary>Get the item at the given index as a scalar tensor.</summary>
</member>
<member name="M:DiffSharp.Tensor.ge(DiffSharp.Tensor)">
 <summary>Computes element-wise \(a \geq b\), returning a boolean tensor containing a <c>true</c> at each location where the comparison is true</summary>
</member>
<member name="M:DiffSharp.Tensor.gather(System.Int32,DiffSharp.Tensor)">
 <summary>Gathers values along an axis specified by dim.</summary>
 <param name="dim">The axis along which to index.</param>
 <param name="indices">The the indices of elements to gather.</param>
</member>
<member name="M:DiffSharp.Tensor.fullLike(System.IConvertible,Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a new tensor filled with the given scalar value for the given shape, element type and configuration, defaulting to the 
 shape and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.forwardDiff(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.UInt32})">
 <summary>
  Returns the input tensor with added support for forward-mode automatic differentiation.
 </summary>
 <remarks>
  Any tensors produced using this tensor will have attached derivatives for forward mode propagation.
  The current global nesting level is used for nested differentiation.
 </remarks>
</member>
<member name="M:DiffSharp.Tensor.floor">
 <summary>Returns a new tensor with the floor of the elements of input, the largest integer less than or equal to each element.</summary>
 <remarks>The tensor will have the same element type as the input tensor.</remarks>
</member>
<member name="M:DiffSharp.Tensor.float64">
<summary>
 Returns a new tensor with each element converted to type float64
</summary>
</member>
<member name="M:DiffSharp.Tensor.float32">
<summary>
 Returns a new tensor with each element converted to type float32
</summary>
</member>
<member name="M:DiffSharp.Tensor.float16">
<summary>
 Returns a new tensor with each element converted to type float16
</summary>
</member>
<member name="M:DiffSharp.Tensor.float">
<summary>
 Returns a new tensor with each element converted to type float64
</summary>
</member>
<member name="M:DiffSharp.Tensor.flip(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Reverse the order of a n-D tensor along given axis in dims</summary>
 <param name="dims">The axis to flip on.</param>
</member>
<member name="M:DiffSharp.Tensor.flatten(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Flattens a contiguous range of dims in a tensor.</summary>
 <param name="startDim">The first dim to flatten.</param>
 <param name="endDim">The last dim to flatten.</param>
</member>
<member name="M:DiffSharp.Tensor.eye(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a 2-D tensor with ones on the diagonal and zeros elsewhere.</summary>
</member>
<member name="M:DiffSharp.Tensor.expandAs(DiffSharp.Tensor)">
 <summary>Expand this tensor to the same size as the other.</summary>
</member>
<member name="M:DiffSharp.Tensor.expand(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Returns a new view of the object tensor with singleton dimensions expanded to a larger size.</summary>
 <remarks>
   <para>Passing -1 as the size for a dimension means not changing the size of that dimension.</para>
   <para>The tensor can be also expanded to a larger number of dimensions, and the new ones will be appended 
         at the front. For the new dimensions, the size cannot be set to -1.
   </para>
   <para>
      Expanding a tensor does not allocate new memory, but only creates a new view on the existing tensor
      where a dimension of size one is expanded to a larger size by setting the stride to 0. Any dimension
      of size 1 can be expanded to an arbitrary value without allocating new memory.
   </para>
 </remarks>
</member>
<member name="M:DiffSharp.Tensor.exp">
 <summary>Applies the exp function element-wise.</summary>
</member>
<member name="M:DiffSharp.Tensor.eq(DiffSharp.Tensor)">
 <summary>Computes element-wise \(a = b\), returning a boolean tensor containing a <c>true</c> at each location where the comparison is true</summary>
</member>
<member name="M:DiffSharp.Tensor.dropout3d(Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>Randomly zero out entire channels (a channel is a 3D feature map, e.g., the jj -th channel of the ii -th sample in the batched input is a 3D tensor \text{input}[i, j]input[i,j] ). Each channel will be zeroed out independently on every forward call with probability p using samples from a Bernoulli distribution.</summary>
 <param name="p">The probability of an element to be zeroed. Default: 0.5.</param>
</member>
<member name="M:DiffSharp.Tensor.dropout2d(Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>Randomly zero out entire channels (a channel is a 2D feature map, e.g., the jj -th channel of the ii -th sample in the batched input is a 2D tensor \text{input}[i, j]input[i,j] ). Each channel will be zeroed out independently on every forward call with probability p using samples from a Bernoulli distribution</summary>
 <param name="p">The probability of an element to be zeroed. Default: 0.5.</param>
</member>
<member name="M:DiffSharp.Tensor.dropout(Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>Randomly zeroes some of the elements of the input tensor with probability p using samples from a Bernoulli distribution</summary>
 <param name="p">The probability of an element to be zeroed. Default: 0.5.</param>
</member>
<member name="M:DiffSharp.Tensor.double">
<summary>
 Returns a new tensor with each element converted to type float64
</summary>
</member>
<member name="M:DiffSharp.Tensor.dot(DiffSharp.Tensor)">
 <summary>Computes the dot product (inner product) of two vector (1d-tensors).</summary>
 <param name="b">The vector to multiply this tensor by (1d-tensor).</param>
 <remarks>This function does not broadcast and expects this tensor to be a vector (1d-tensor).   
 The tensors must have the same number of elements.
 </remarks>
</member>
<member name="M:DiffSharp.Tensor.div(System.IConvertible)">
 <summary>Divides each element of the object tensor by the scalar <paramref name="b" />. The resulting tensor is returned.</summary>
 <remarks>The shapes of the two tensors must be broadcastable.</remarks>
</member>
<member name="M:DiffSharp.Tensor.div(DiffSharp.Tensor)">
 <summary>Divides each element of the object tensor by the corresponding element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
 <remarks>The shapes of the two tensors must be broadcastable.</remarks>
</member>
<member name="M:DiffSharp.Tensor.dilate(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Dilate the tensor in using the given dilations in each corresponding dimension.</summary>
 <param name="dilations">The dilations to use.</param>
</member>
<member name="M:DiffSharp.Tensor.diagonal(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
  Returns a tensor with the diagonal elements with respect to <c>dim1</c> and <c>dim2</c>.
  The argument offset controls which diagonal to consider.
 </summary>
</member>
<member name="M:DiffSharp.Tensor.crossEntropyLoss(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>This criterion combines logsoftmax and nllLoss in a single function</summary>
 <param name="target">The target tensor.</param>
 <param name="weight">A optional manual rescaling weight given to the loss of each batch element.</param>
 <param name="reduction">Optionally specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: size_average and reduce are in the process of being deprecated, and in the meantime, specifying either of those two args will override reduction. Default: 'mean'.</param>
</member>
<member name="M:DiffSharp.Tensor.create(System.Object,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>
 Creates a new tensor from the given data, using the given element type and configuration.
 </summary>
 <param name="value">The .NET object used to form the initial values for the tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
 <remarks>The fastest creation technique is a one dimensional array matching the desired dtype. Then use 'view' to reshape.</remarks>
</member>
<member name="M:DiffSharp.Tensor.cpu">
<summary>
 Returns a new tensor with the same contents moved to the CPU
</summary>
</member>
<member name="M:DiffSharp.Tensor.cov(Microsoft.FSharp.Core.FSharpOption{System.Int64},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor})">
 <summary>
 Estimates the covariance matrix of the given tensor. The tensor's first
 dimension should index variables and the second dimension should
 index observations for each variable.
 </summary>
 <remarks>
 If no weights are given, the covariance between variables \(x\) and \(y\) is
  \[cov(x,y)= \frac{\sum^{N}_{i = 1}(x_{i} - \mu_x)(y_{i} - \mu_y)}{N~-~\text{correction}}\]
 where \(\mu_x\) and \(\mu_y\) are the sample means.
 
 If there are fweights or aweights then the covariance is
 \[cov(x,y)=\frac{\sum^{N}_{i = 1}w_i(x_{i} - \mu_x^*)(y_{i} - \mu_y^*)}{\text{normalization factor}}\]
 where \(w\) is either fweights or aweights if one weight type is provided.
 If both weight types are provided \(w=\text{fweights}\times\text{aweights}\). 
 \(\mu_x^* = \frac{\sum^{N}_{i = 1}w_ix_{i} }{\sum^{N}_{i = 1}w_i}\)
 is the weighted mean of variables.
 The normalization factor is \(\sum^{N}_{i=1} w_i\) if only fweights are provided or if aweights are provided and <c>correction=0</c>. 
 Otherwise if aweights \(aw\) are provided the normalization factor is
  \(\sum^N_{i=1} w_i - \text{correction}\times\frac{\sum^N_{i=1} w_i aw_i}{\sum^N_{i=1} w_i}\) 
 </remarks>
 <param name="correction">Difference between the sample size and the sample degrees of freedom. Defaults to 1 (Bessel's correction).</param>
 <param name="fweights">Frequency weights represent the number of times each observation was observed. 
 Should be given as a tensor of integers. Defaults to no weights.</param>
 <param name="aweights">Relative importance weights, larger weights for observations that
 should have a larger effect on the estimate. 
 Should be given as a tensor of floating point numbers. Defaults to no weights.</param>
 <returns>Returns a square tensor representing the covariance matrix.
  Given a tensor with \(N\) variables \(X=[x_1,x_2,\ldots,x_N]\) the
 \(C_{i,j}\) entry on the covariance matrix is the covariance between
 \(x_i\) and \(x_j\).
 </returns>
 <example id="tensor-covariance1">
 <code lang="fsharp">
 let x = dsharp.tensor([0.0;3.4;5.0])
 let y = dsharp.tensor([1.0;2.3;-3.0])
 let xy = dsharp.stack([x;y])
 xy.cov()
 </code>
 Evaluates to
 <code>
 tensor([[ 6.5200, -4.0100],
         [-4.0100,  7.6300]])
 </code>
 </example>
</member>
<member name="M:DiffSharp.Tensor.cosh">
 <summary>Returns a new tensor with the hyperbolic cosine of the elements of input.</summary>
</member>
<member name="M:DiffSharp.Tensor.cos">
 <summary>Returns a new tensor with the cosine of the elements of input</summary>
</member>
<member name="M:DiffSharp.Tensor.corrcoef">
 <summary>
 Estimates the Pearson correlation coefficient matrix for the given tensor. The tensor's first
 dimension should index variables and the second dimension should
 index observations for each variable.
 </summary>
 <returns>
 The correlation coefficient matrix \(R\) is computed from the covariance
 matrix 
 Returns a square tensor representing the correlation coefficient matrix.
  Given a tensor with \(N\) variables \(X=[x_1,x_2,\ldots,x_N]\) the
 \(R_{i,j}\) entry on the correlation matrix is the correlation between
 \(x_i\) and \(x_j\).
 </returns>
 <remarks>
 The correlation between variables \(x\) and \(y\) is
  \[cor(x,y)= \frac{\sum^{N}_{i = 1}(x_{i} - \mu_x)(y_{i} - \mu_y)}{\sigma_x \sigma_y (N ~-~1)}\]
 where \(\mu_x\) and \(\mu_y\) are the sample means and \(\sigma_x\) and \(\sigma_x\) are 
 the sample standard deviations.
 </remarks>
 <example id="tensor-correlation1">
 <code lang="fsharp">
 let x = dsharp.tensor([-0.2678; -0.0908; -0.3766;  0.2780])
 let y = dsharp.tensor([-0.5812;  0.1535;  0.2387;  0.2350])
 let xy = dsharp.stack([x;y])
 xy.corrcoef()
 </code>
 Evaluates to
 <code>
 tensor([[1.0000, 0.3582],
         [0.3582, 1.0000]])
 </code>
 </example>
</member>
<member name="M:DiffSharp.Tensor.convTranspose3d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 3D transposed convolution operator over an input signal composed of several input planes, sometimes also called 'deconvolution'.</summary>
 <param name="filters">The filters.</param>
 <param name="stride">The stride of the convolving kernel.</param>
 <param name="padding">The implicit padding on both sides of the input.</param>
 <param name="dilation">The spacing between kernel elements.</param>
 <param name="strides">The strides of the convolving kernel.</param>
 <param name="paddings">The implicit paddings on corresponding sides of the input.</param>
 <param name="dilations">The spacings between kernel elements.</param>
 <param name="outputPadding">The additional size added to one side of each dimension in the output shape.</param>
 <param name="outputPaddings">The additional sizes added to one side of each dimension in the output shape.</param>
</member>
<member name="M:DiffSharp.Tensor.convTranspose2d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 2D transposed convolution operator over an input signal composed of several input planes, sometimes also called 'deconvolution'.</summary>
 <param name="filters">The filters.</param>
 <param name="stride">The stride of the convolving kernel.</param>
 <param name="padding">The implicit padding on both sides of the input.</param>
 <param name="dilation">The spacing between kernel elements.</param>
 <param name="strides">The strides of the convolving kernel.</param>
 <param name="paddings">The implicit paddings on corresponding sides of the input.</param>
 <param name="dilations">The spacings between kernel elements.</param>
 <param name="outputPadding">The additional size added to one side of each dimension in the output shape.</param>
 <param name="outputPaddings">The additional sizes added to one side of each dimension in the output shape.</param>
</member>
<member name="M:DiffSharp.Tensor.convTranspose1d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Applies a 1D transposed convolution operator over an input signal composed of several input planes, sometimes also called 'deconvolution'.</summary>
 <param name="filters">The filters.</param>
 <param name="stride">The stride of the convolving kernel.</param>
 <param name="padding">The implicit padding on both sides of the input.</param>
 <param name="dilation">The spacing between kernel elements.</param>
 <param name="outputPadding">The additional size added to one side of each dimension in the output shape.</param>
</member>
<member name="M:DiffSharp.Tensor.conv3d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 3D convolution over an input signal composed of several input planes</summary>
 <param name="filters">The filters.</param>
 <param name="stride">The stride of the convolving kernel.</param>
 <param name="padding">The implicit padding on corresponding sides of the input.</param>
 <param name="dilation">The spacing between kernel elements.</param>
 <param name="strides">The strides of the convolving kernel.</param>
 <param name="paddings">The implicit paddings on corresponding sides of the input.</param>
 <param name="dilations">The spacings between kernel elements.</param>
</member>
<member name="M:DiffSharp.Tensor.conv2d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 2D convolution over an input signal composed of several input planes</summary>
 <param name="filters">The filters.</param>
 <param name="stride">The stride of the convolving kernel.</param>
 <param name="padding">The implicit padding on corresponding sides of the input.</param>
 <param name="dilation">The spacing between kernel elements.</param>
 <param name="strides">The strides of the convolving kernel.</param>
 <param name="paddings">The implicit paddings on corresponding sides of the input.</param>
 <param name="dilations">The spacings between kernel elements.</param>
</member>
<member name="M:DiffSharp.Tensor.conv1d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Applies a 1D convolution over an input signal composed of several input planes</summary>
 <param name="filters">The filters.</param>
 <param name="stride">The stride of the convolving kernel.</param>
 <param name="padding">The implicit paddings on both sides of the input.</param>
 <param name="dilation">The spacing between kernel elements.</param>
</member>
<member name="M:DiffSharp.Tensor.clone">
 <summary>Returns a new tensor with underlying storage copied.</summary>
 <remarks>
   This method discards differentiability and returns a constant tensor.
 </remarks>
</member>
<member name="M:DiffSharp.Tensor.clamp(Microsoft.FSharp.Core.FSharpOption{System.IConvertible},Microsoft.FSharp.Core.FSharpOption{System.IConvertible})">
 <summary>Clamp all elements in input into the range [ low..high] and return a resulting tensor</summary>
 <param name="low">The lower-bound of the range to be clamped to.</param>
 <param name="high">The upper-bound of the range to be clamped to.</param>
</member>
<member name="M:DiffSharp.Tensor.ceil">
 <summary>Returns a new tensor with the ceil of the elements of input, the smallest integer greater than or equal to each element.</summary>
 <remarks>The tensor will have the same element type as the input tensor.</remarks>
</member>
<member name="M:DiffSharp.Tensor.cat(System.Collections.Generic.IEnumerable{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Concatenates the given sequence of seq tensors in the given dimension.</summary>
 <remarks>All tensors must either have the same shape (except in the concatenating dimension) or be empty.</remarks>
 <param name="tensors">The tensors to concatenate.</param>
 <param name="dim">The dimension over which the tensors are concatenated, defaults to 0.</param>
</member>
<member name="M:DiffSharp.Tensor.cast``1">
<summary>
 Converts the tensor to a new tensor with the given system type
</summary>
</member>
<member name="M:DiffSharp.Tensor.cast(DiffSharp.Dtype)">
<summary>
 Converts the tensor to a new tensor with the given &lt;see cref=&quot;T:DiffSharp.Dtype&quot;/&gt;
</summary>
</member>
<member name="M:DiffSharp.Tensor.byte">
<summary>
 Returns a new tensor with each element converted to type float64
</summary>
</member>
<member name="M:DiffSharp.Tensor.bool">
<summary>
 Returns a new tensor with each element converted to type bool
</summary>
</member>
<member name="M:DiffSharp.Tensor.bfloat16">
<summary>
 Returns a new tensor with each element converted to type bfloat16
</summary>
</member>
<member name="M:DiffSharp.Tensor.bernoulli(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Draws binary random numbers (0 or 1) from a Bernoulli distribution</summary>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.Tensor.bceLoss(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>Creates a criterion that measures the Binary Cross Entropy between the target and the output</summary>
 <param name="target">The target tensor.</param>
 <param name="weight">A manual rescaling weight given to the loss of each batch element.</param>
 <param name="reduction">Optionally specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: size_average and reduce are in the process of being deprecated, and in the meantime, specifying either of those two args will override reduction. Default: 'mean'.</param>
</member>
<member name="M:DiffSharp.Tensor.backward(DiffSharp.Tensor)">
 <summary>See <c>reverse</c></summary>
</member>
<member name="M:DiffSharp.Tensor.atan">
 <summary>Returns a new tensor with the arctangent of the elements of input.</summary>
</member>
<member name="M:DiffSharp.Tensor.asin">
 <summary>Returns a new tensor with the arcsine of the elements of input.</summary>
</member>
<member name="M:DiffSharp.Tensor.argmin(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the indexes of minimum values of the primal of the tensor, reducing the given dimension.</summary>
 <remarks>The resulting tensor does not participate in reverse or forward differentiation. It can be used as input to another operation such as <c>dsharp.gather</c>.</remarks>
</member>
<member name="M:DiffSharp.Tensor.argmin">
<summary>
 Gets the index of a minimum value in the tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.argmax(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the indexes of maximum values of the primal of the tensor, reducing the given dimension.</summary>
 <remarks>The resulting tensor does not participate in reverse or forward differentiation. It can be used as input to another operation such as <c>dsharp.gather</c>.</remarks>
</member>
<member name="M:DiffSharp.Tensor.argmax">
<summary>
 Gets the index of a maximum value in the tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.arangeLike(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a tensor in the manner of &lt;see cref=&quot;M:DiffSharp.dsharp.arange&quot;/&gt; for the given element type and configuration, defaulting to
 the element type and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.arangeLike(System.Double,Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Returns a tensor in the manner of &lt;see cref=&quot;M:DiffSharp.dsharp.arange&quot;/&gt; for the given element type and configuration, defaulting to
 the element type and configuration of the input tensor.
</summary>
</member>
<member name="M:DiffSharp.Tensor.ancestors">
<summary>
 A debugging routine that returns the ancestors of a tensor involved in reverse-mode automatic differentiation
</summary>
</member>
<member name="M:DiffSharp.Tensor.allclose(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double})">
<summary>
 Indicates if two tensors have the same shape and all corresponding elements are equal within the
 given tolerances.
</summary>
</member>
<member name="M:DiffSharp.Tensor.addSlice(System.Collections.Generic.IEnumerable{System.Int32},DiffSharp.Tensor)">
 <summary>Add the given tensor as a slice at the given location.</summary>
</member>
<member name="M:DiffSharp.Tensor.add(System.IConvertible)">
 <summary>Each element of the object tensor is added to the scalar <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.add(DiffSharp.Tensor)">
 <summary>Each element of the object tensor is added to each corresponding element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
 <remarks>The shapes of the two tensors must be broadcastable.</remarks>
</member>
<member name="M:DiffSharp.Tensor.acos">
 <summary>Returns a new tensor with the arccosine of the elements of input.</summary>
</member>
<member name="M:DiffSharp.Tensor.abs">
 <summary>Computes the element-wise absolute value of the given input tensor.</summary>
</member>
<member name="M:DiffSharp.Tensor.Tanh(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>tanh</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Tan(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>tan</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Sqrt(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>sqrt</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Sinh(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>sinh</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Sin(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>sin</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Round(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>round</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Pow(System.Int32,DiffSharp.Tensor)">
 <summary>Raises the scalar <paramref name="a" /> to the power of each element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.Pow(System.Double,DiffSharp.Tensor)">
 <summary>Raises the scalar <paramref name="a" /> to the power of each element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.Pow(System.IConvertible,DiffSharp.Tensor)">
 <summary>Raises the scalar <paramref name="a" /> to the power of each element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.Pow(DiffSharp.Tensor,System.Int32)">
 <summary>Raises each element of the tensor <paramref name="a" /> to the power of the scalar <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.Pow(DiffSharp.Tensor,System.Double)">
 <summary>Raises each element of the tensor <paramref name="a" /> to the power of the scalar <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.Pow(DiffSharp.Tensor,System.IConvertible)">
 <summary>Raises each element of the tensor <paramref name="a" /> to the power of the scalar <paramref name="b" />. The resulting tensor is returned.</summary>
</member>
<member name="M:DiffSharp.Tensor.Pow(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Raises each element of the tensor <paramref name="a" /> to the power of the corresponding element of the tensor <paramref name="b" />. The resulting tensor is returned.</summary>
 <remarks>The shapes of the two tensors must be broadcastable.</remarks>
</member>
<member name="M:DiffSharp.Tensor.Op(DiffSharp.BinaryOp)">
 <summary>Allows the definition of a new binary tensor op.</summary>
 <param name="ext">The definition of the new op.</param>
 <returns>The new op.</returns>
</member>
<member name="M:DiffSharp.Tensor.Op(DiffSharp.UnaryOp)">
 <summary>Allows the definition of a new unary tensor op.</summary>
 <param name="ext">The definition of the new op.</param>
 <returns>The new op.</returns>
</member>
<member name="M:DiffSharp.Tensor.Log10(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>log10</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Log(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>log</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Floor(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>floor</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Exp(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>exp</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Cosh(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>cosh</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Cos(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>cos</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Ceiling(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>ceil</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Atan(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>atan</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Asin(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>asin</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Acos(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>acos</c>.</summary>
</member>
<member name="M:DiffSharp.Tensor.Abs(DiffSharp.Tensor)">
 <summary>A method to enable the use of the F# function <c>abs</c>.</summary>
</member>
<member name="T:DiffSharp.Tensor">
 <summary>
   Represents a multi-dimensional data type containing elements of a single data type.
 </summary>

 <example>
   A tensor can be constructed from a list or sequence using <see cref="M:DiffSharp.dsharp.tensor(System.Object)" />

  <code>
    let t = dsharp.tensor([[1.; -1.]; [1.; -1.]])
  </code>
 </example>
</member>
<member name="M:DiffSharp.dsharp.zerosLike(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new tensor filled with '0' values with characteristics based on the input tensor.</summary>
 <param name="input">The shape and characteristics of input will determine those of the output tensor.</param>
 <param name="shape">The desired shape of returned tensor. Default: If None, the shape of the input tensor is used.</param>
 <param name="device">The desired device of returned tensor. Default: if None, the device of the input tensor is used.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, the element type of the input tensor is used.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, the backend of the input tensor is used.</param>
</member>
<member name="M:DiffSharp.dsharp.zeros(System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new tensor filled with '0' values for the given length, element type and configuration</summary>
 <param name="length">The length of the returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.zeros(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new tensor filled with '0' values for the given shape, element type and configuration</summary>
 <param name="shape">The desired shape of returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.zeroLike(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns the '0' scalar tensor with characteristics based on the input tensor.</summary>
 <param name="input">The shape and characteristics of input will determine those of the output tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, the device of the input tensor is used.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, the element type of the input tensor is used.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, the backend of the input tensor is used.</param>
</member>
<member name="M:DiffSharp.dsharp.zeroCreate(System.Int32)">
 <summary>Create a new 1D tensor using '0' as value for each element.</summary>
 <param name="count">The number of elements in the tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.zero(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Get the scalar zero tensor for the given configuration</summary>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.viewAs(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>View this tensor as the same size as other.</summary>
 <remarks>The returned tensor shares the same data and must have the same number of elements, but may have a different size. For a tensor to be viewed, the new view size must be compatible with its original size.
   The returned tensor shares the same data and must have the same number of elements, but may have a different size. 
   For a tensor to be viewed, the new view size must be compatible with its original size and stride, i.e., each new view dimension must either be a subspace of an original dimension,
   or only span across original dimensions \(d, d+1, \dots, d+kd,d+1,…,d+k\) that satisfy the following contiguity-like condition that
   \(\forall i = d, \dots, d+k-1∀i=d,…,d+k−1 ,\) \[\text{stride}[i] = \text{stride}[i+1] \times \text{size}[i+1]\]
 </remarks>
 <param name="input">The input tensor.</param>
 <param name="other">The result tensor has the same size as other.</param>
</member>
<member name="M:DiffSharp.dsharp.view(DiffSharp.Tensor,System.Int32)">
 <summary>Returns a new tensor with the same data as the self tensor but of a different shape.</summary>
 <remarks>The returned tensor shares the same data and must have the same number of elements, but may have a different size. For a tensor to be viewed, the new view size must be compatible with its original size.
   The returned tensor shares the same data and must have the same number of elements, but may have a different size. 
   For a tensor to be viewed, the new view size must be compatible with its original size and stride, i.e., each new view dimension must either be a subspace of an original dimension,
   or only span across original dimensions \(d, d+1, \dots, d+kd,d+1,…,d+k\) that satisfy the following contiguity-like condition that
   \(\forall i = d, \dots, d+k-1∀i=d,…,d+k−1 ,\) \[\text{stride}[i] = \text{stride}[i+1] \times \text{size}[i+1]\]
 </remarks>
 <param name="input">The input tensor.</param>
 <param name="shape">The desired shape of returned tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.view(DiffSharp.Tensor,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Returns a new tensor with the same data as the self tensor but of a different shape.</summary>
 <remarks>The returned tensor shares the same data and must have the same number of elements, but may have a different size. For a tensor to be viewed, the new view size must be compatible with its original size.
   The returned tensor shares the same data and must have the same number of elements, but may have a different size. 
   For a tensor to be viewed, the new view size must be compatible with its original size and stride, i.e., each new view dimension must either be a subspace of an original dimension,
   or only span across original dimensions \(d, d+1, \dots, d+kd,d+1,…,d+k\) that satisfy the following contiguity-like condition that
   \(\forall i = d, \dots, d+k-1∀i=d,…,d+k−1 ,\) \[\text{stride}[i] = \text{stride}[i+1] \times \text{size}[i+1]\]
 </remarks>
 <param name="input">The input tensor.</param>
 <param name="shape">The desired shape of returned tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.var(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the variance of each row of the input tensor in the given dimension dim. If dim is a list of dimensions, reduce over all of them.</summary>
 <remarks>
  If keepdim is true, the output tensor is of the same size as input except in the dimension(s) dim where it is of size 1. Otherwise, dim is squeezed, resulting in the output tensor having 1 (or len(dim)) fewer dimension(s).
  If unbiased is False, then the variance will be calculated via the biased estimator. Otherwise, Bessel’s correction will be used.
 </remarks>
 <param name="input">The input tensor.</param>
 <param name="dim">The dimension to reduce.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
 <param name="unbiased">Whether to use the unbiased estimation or not.</param>
</member>
<member name="M:DiffSharp.dsharp.var(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the variance of all elements in the input tensor.</summary>
 <remarks>
  If unbiased is False, then the variance will be calculated via the biased estimator. Otherwise, Bessel’s correction will be used.
 </remarks>
 <param name="input">The input tensor.</param>
 <param name="unbiased">Whether to use the unbiased estimation or not.</param>
</member>
<member name="M:DiffSharp.dsharp.unstack(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Removes a tensor dimension</summary>
 <param name="input">The input tensor.</param>
 <param name="dim">The dimension to remove.</param>
</member>
<member name="M:DiffSharp.dsharp.unsqueezeAs(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Returns a new tensor with dimensions of size one appended to the end until the number of dimensions is the same as the other tensor.</summary>
 <param name="input">The input tensor.</param>
 <param name="other">The other tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.unsqueeze(DiffSharp.Tensor,System.Int32)">
 <summary>Returns a new tensor with a dimension of size one inserted at the specified position</summary>
 <param name="input">The input tensor.</param>
 <param name="dim">The index at which to insert the singleton dimension.</param>
</member>
<member name="M:DiffSharp.dsharp.unflatten(DiffSharp.Tensor,System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Unflattens a tensor dimension by expanding it to the given shape.</summary>
 <param name="input">The input tensor.</param>
 <param name="dim">The dimension to unflatten.</param>
 <param name="unflattenedShape">New shape of the unflattened dimenension.</param>
</member>
<member name="M:DiffSharp.dsharp.undilate(DiffSharp.Tensor,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Reverse the dilation of the tensor in using the given dilations in each corresponding dimension.</summary>
 <param name="input">The input tensor.</param>
 <param name="dilations">The dilations to use.</param>
</member>
<member name="M:DiffSharp.dsharp.transpose(DiffSharp.Tensor)">
 <summary>Returns a tensor that is a transposed version of input with dimensions 0 and 1 swapped.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.transpose(DiffSharp.Tensor,System.Int32,System.Int32)">
 <summary>Returns a tensor that is a transposed version of input. The given dimensions dim0 and dim1 are swapped.</summary>
 <param name="input">The input tensor.</param>
 <param name="dim0">The first dimension to be transposed.</param>
 <param name="dim1">The second dimension to be transposed.</param>
</member>
<member name="M:DiffSharp.dsharp.trace(DiffSharp.Tensor)">
 <summary>Returns the sum of the elements of the diagonal of the input 2-D matrix</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.toImageString(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>Convert tensor to a grayscale image tensor and return a string representation approximating grayscale values</summary>
 <param name="input">The input tensor.</param>
 <param name="pixelMin">The minimum pixel value.</param>
 <param name="pixelMax">The maximum pixel value.</param>
 <param name="normalize">If True, shift the image to the range (0, 1), by the min and max values specified by range.</param>
 <param name="gridCols">Number of columns of images in the grid.</param>
 <param name="asciiPalette">The ASCII pallette to use.</param>
</member>
<member name="M:DiffSharp.dsharp.toImage(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Convert tensor to an image tensor with shape Channels x Height x Width</summary>
 <remarks>If the input tensor has 4 dimensions, then make a single image grid.</remarks>
 <param name="input">The input tensor.</param>
 <param name="pixelMin">The minimum pixel value.</param>
 <param name="pixelMax">The maximum pixel value.</param>
 <param name="normalize">If True, shift the image to the range (0, 1), by the min and max values specified by range.</param>
 <param name="gridCols">Number of columns of images in the grid.</param>
</member>
<member name="M:DiffSharp.dsharp.tensor(System.Object,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>
 Creates a new tensor from the given data, using the given element type and configuration.
 </summary>
 
 <example><code>
    let t1 = dsharp.tensor [ 1 .. 10 ]
    let t2 = dsharp.tensor [ [ 1.0; 3.0; 4.0 ];
                             [ 1.02; 3.04; 4.01 ] ]
 </code></example>
 
 <remarks>
  The data is converted from arrays, sequences, lists and tuples of primitive values to a tensor whose shape is inferred from the data.
 </remarks>
 <param name="value">The .NET object used to form the initial values for the tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
 <remarks>The fastest creation technique is a one dimensional array matching the desired dtype. Then use 'view' to reshape.</remarks>
</member>
<member name="M:DiffSharp.dsharp.tanh(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the hyperbolic tangent of the elements of input.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.tan(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the tangent of the elements of input</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.sum(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the sum of each row of the input tensor in the given dimension dim. If dim is a list of dimensions, reduce over all of them.</summary>
 <remarks>
  If keepdim is true, the output tensor is of the same size as input except in the dimension(s) dim where it is of size 1. Otherwise, dim is squeezed, resulting in the output tensor having 1 (or len(dim)) fewer dimension(s).
 </remarks>
 <param name="input">The input tensor.</param>
 <param name="dim">The dimension to reduce.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
</member>
<member name="M:DiffSharp.dsharp.sum(DiffSharp.Tensor)">
 <summary>Returns the sum of all elements in the input tensor</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.sub(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Return the element-wise subtraction of the two tensors.</summary>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.std(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the standard deviation of each row of the input tensor in the given dimension dim. If dim is a list of dimensions, reduce over all of them.</summary>
 <remarks>
  If keepdim is true, the output tensor is of the same size as input except in the dimension(s) dim where it is of size 1. Otherwise, dim is squeezed, resulting in the output tensor having 1 (or len(dim)) fewer dimension(s).
  If unbiased is False, then the standard deviation will be calculated via the biased estimator. Otherwise, Bessel’s correction will be used.
 </remarks>
 <param name="input">The input tensor.</param>
 <param name="dim">The dimension to reduce.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
 <param name="unbiased">Whether to use the unbiased estimation or not.</param>
</member>
<member name="M:DiffSharp.dsharp.std(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the standard deviation of all elements in the input tensor.</summary>
 <remarks>
  If unbiased is False, then the standard deviation will be calculated via the biased estimator. Otherwise, Bessel’s correction will be used.
 </remarks>
 <param name="input">The input tensor.</param>
 <param name="unbiased">Whether to use the unbiased estimation or not.</param>
</member>
<member name="M:DiffSharp.dsharp.standardize(DiffSharp.Tensor)">
 <summary>Returns the tensor after standardization (z-score normalization)</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.stack(System.Collections.Generic.IEnumerable{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Concatenates sequence of tensors along a new dimension</summary>
 <remarks>All tensors need to be of the same size.</remarks>
 <param name="tensors">The sequence of tensors to concatenate.</param>
 <param name="dim">The dimension to insert. Has to be between 0 and the number of dimensions of concatenated tensors (inclusive).</param>
</member>
<member name="M:DiffSharp.dsharp.squeeze(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Returns a tensor with all the dimensions of input of size 1 removed.</summary>
 <remarks>If the tensor has a batch dimension of size 1, then squeeze(input) will also remove the batch dimension, which can lead to unexpected errors.</remarks>
 <param name="input">The input tensor.</param>
 <param name="dim">If given, the input will be squeezed only in this dimension.</param>
</member>
<member name="M:DiffSharp.dsharp.sqrt(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the square-root of the elements of input.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.split(DiffSharp.Tensor,System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Splits the tensor into chunks. The tensor will be split into sizes.Length chunks each with a corresponding size in the given dimension.</summary>
 <param name="input">The tensor to split.</param>
 <param name="sizes">The size of a single chunk or list of sizes for each chunk.</param>
 <param name="dim">The dimension along which to split the tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.softplus(DiffSharp.Tensor)">
 <summary>Applies the softplus function element-wise.</summary>
 <remarks>\[\text{Softplus}(x) = \frac{1}{\beta} * \log(1 + \exp(\beta * x))\]</remarks>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.softmax(DiffSharp.Tensor,System.Int32)">
 <summary>Applies a softmax function.</summary>
 <remarks>Softmax is defined as: \text{Softmax}(x_{i}) = \frac{\exp(x_i)}{\sum_j \exp(x_j)}.</remarks>
 <param name="input">The input tensor.</param>
 <param name="dim">A dimension along which softmax will be computed.</param>
</member>
<member name="M:DiffSharp.dsharp.slice(DiffSharp.Tensor,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Get a slice of a tensor</summary>
 <param name="input">The input tensor.</param>
 <param name="index">Index describing the slice.</param>
</member>
<member name="M:DiffSharp.dsharp.sinh(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the hyperbolic sine of the elements of input.</summary>
</member>
<member name="M:DiffSharp.dsharp.sin(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the sine of the elements of input</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.sign(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the signs of the elements of input.</summary>
 <remarks>The tensor will have the same element type as the input tensor.</remarks>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.sigmoid(DiffSharp.Tensor)">
 <summary>Applies the sigmoid element-wise function</summary>
 <remarks>\[\text{Sigmoid}(x) = \frac{1}{1 + \exp(-x)}\]</remarks>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.seed(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Seeds all backends with the given random seed, or a new seed based on the current time if no seed is specified.</summary>
</member>
<member name="M:DiffSharp.dsharp.scatter(DiffSharp.Tensor,System.Int32,DiffSharp.Tensor,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Gathers values along an axis specified by dim.</summary>
 <param name="input">The input tensor.</param>
 <param name="dim">The axis along which to index.</param>
 <param name="indices">The the indices of elements to gather.</param>
 <param name="destinationShape">The destination shape.</param>
</member>
<member name="M:DiffSharp.dsharp.scalar(System.IConvertible,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new scalar tensor with the value <paramref name="value" />, for the given element type and configuration</summary>
 <param name="value">The scalar giving the the initial values for the tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.save(System.Object,System.String)">
 <summary>Saves the object to the given file using a bespoke binary format.</summary>
 <remarks>
   The format used may change from version to version of DiffSharp.
 </remarks>
</member>
<member name="M:DiffSharp.dsharp.safelog(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>Returns the logarithm of the tensor after clamping the tensor so that all its elements are greater than epsilon. This is to avoid a -inf result for elements equal to zero.</summary>
 <param name="input">The input tensor.</param>
 <param name="epsilon">The smallest value a tensor element can take before the logarithm is applied. Default: 1e-12</param>
</member>
<member name="M:DiffSharp.dsharp.round(DiffSharp.Tensor)">
 <summary>Returns a new tensor with each of the elements of input rounded to the closest integer.</summary>
 <remarks>The tensor will have the same element type as the input tensor.</remarks>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.reverseReset(DiffSharp.Tensor)">
 <summary>Reset the reverse mode computation associated with the given output tensor.</summary>
 <param name="tensor">The output tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.reversePush(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Push the given value as part of the reverse-mode computation at the given output tensor.</summary>
 <param name="value">The value to apply.</param>
 <param name="tensor">The output tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.reverseDiff(System.UInt32,DiffSharp.Tensor)">
 <summary>Produce a new tensor suitable for calculating the reverse-mode derivative at the given level tag.</summary>
 <param name="nestingTag">The level tag.</param>
 <param name="tensor">The output tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.reverse(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Compute the reverse-mode derivative at the given output tensor.</summary>
 <param name="value">The value to apply.</param>
 <param name="tensor">The output tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.repeat(DiffSharp.Tensor,System.Int32,System.Int32)">
 <summary>Repeat elements of a tensor</summary>
 <param name="input">The input tensor.</param>
 <param name="dim">The dimension along which to repeat values.</param>
 <param name="times">The number of repetitions for each element.</param>
</member>
<member name="M:DiffSharp.dsharp.relu(DiffSharp.Tensor)">
 <summary>Applies the rectified linear unit function element-wise.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.randnLike(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a tensor filled with random numbers from a normal distribution with mean 0 and variance 1 (also called the standard normal distribution) with characteristics based on the input tensor.</summary>
 <param name="input">The shape and characteristics of input will determine those of the output tensor.</param>
 <param name="shape">The desired shape of returned tensor. Default: If None, the shape of the input tensor is used.</param>
 <param name="device">The desired device of returned tensor. Default: if None, the device of the input tensor is used.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, the element type of the input tensor is used.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, the backend of the input tensor is used.</param>
</member>
<member name="M:DiffSharp.dsharp.randn(System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a tensor filled with random numbers from a normal distribution with mean 0 and variance 1 (also called the standard normal distribution).</summary>
 <param name="length">The length of the returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.randn(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a tensor filled with random numbers from a normal distribution with mean 0 and variance 1 (also called the standard normal distribution).</summary>
 <param name="shape">The desired shape of returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.randintLike(DiffSharp.Tensor,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a tensor with the same shape as Tensor input filled with random integers generated uniformly between low (inclusive) and high (exclusive) with characteristics based on the input tensor.</summary>
 <param name="input">The shape and characteristics of input will determine those of the output tensor.</param>
 <param name="low">Lowest integer to be drawn from the distribution. Default: 0..</param>
 <param name="high">One above the highest integer to be drawn from the distribution.</param>
 <param name="shape">The desired shape of returned tensor. Default: If None, the shape of the input tensor is used.</param>
 <param name="device">The desired device of returned tensor. Default: if None, the device of the input tensor is used.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, the element type of the input tensor is used.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, the backend of the input tensor is used.</param>
</member>
<member name="M:DiffSharp.dsharp.randint(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a tensor filled with random integers generated uniformly between low (inclusive) and high (exclusive).</summary>
 <param name="low">Lowest integer to be drawn from the distribution. Default: 0..</param>
 <param name="high">One above the highest integer to be drawn from the distribution.</param>
 <param name="length">The length of the returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.randint(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a tensor filled with random integers generated uniformly between low (inclusive) and high (exclusive).</summary>
 <param name="low">Lowest integer to be drawn from the distribution. Default: 0..</param>
 <param name="high">One above the highest integer to be drawn from the distribution.</param>
 <param name="shape">The desired shape of returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.randLike(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a tensor filled with random numbers from a uniform distribution on the interval [0, 1) with characteristics based on the input tensor</summary>
 <param name="input">The shape and characteristics of input will determine those of the output tensor.</param>
 <param name="shape">The desired shape of returned tensor. Default: If None, the shape of the input tensor is used.</param>
 <param name="device">The desired device of returned tensor. Default: if None, the device of the input tensor is used.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, the element type of the input tensor is used.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, the backend of the input tensor is used.</param>
</member>
<member name="M:DiffSharp.dsharp.rand(System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a tensor filled with random numbers from a uniform distribution on the interval [0, 1)</summary>
 <param name="length">The length of the returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.rand(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a tensor filled with random numbers from a uniform distribution on the interval [0, 1)</summary>
 <param name="shape">The desired shape of returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.primalDerivative(DiffSharp.Tensor)">
 <summary>Get the primal and derivative values of the tensor.</summary>
</member>
<member name="M:DiffSharp.dsharp.primal(DiffSharp.Tensor)">
 <summary>Get the primal value of the tensor.</summary>
</member>
<member name="M:DiffSharp.dsharp.pow(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Return the element-wise exponentiation of the two tensors.</summary>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.permute(DiffSharp.Tensor,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Returns the original tensor with its dimensions permuted.</summary>
 <param name="input">The input tensor.</param>
 <param name="permutation">The desired ordering of dimensions.</param>
</member>
<member name="M:DiffSharp.dsharp.pad(DiffSharp.Tensor,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Add zero padding to each side of a tensor</summary>
 <param name="input">The input tensor.</param>
 <param name="paddings">The implicit paddings on corresponding sides of the input.</param>
</member>
<member name="M:DiffSharp.dsharp.onesLike(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new tensor filled with '1' values with characteristics based on the input tensor.</summary>
 <param name="input">The shape and characteristics of input will determine those of the output tensor.</param>
 <param name="shape">The desired shape of returned tensor. Default: If None, the shape of the input tensor is used.</param>
 <param name="device">The desired device of returned tensor. Default: if None, the device of the input tensor is used.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, the element type of the input tensor is used.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, the backend of the input tensor is used.</param>
</member>
<member name="M:DiffSharp.dsharp.ones(System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new tensor of the given length filled with '1' values for the given element type and configuration</summary>
 <param name="length">The length of the returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.ones(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new tensor filled with '1' values for the given shape, element type and configuration</summary>
 <param name="shape">The desired shape of returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.onehotLike(DiffSharp.Tensor,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>
 A version of dsharp.onehot with characteristics based on the input tensor.
 </summary>
 
 <param name="input">The shape and characteristics of input will determine those of the output tensor.</param>
 <param name="length">The length of the returned tensor.</param>
 <param name="hot">The location to set to 1.</param>
 <param name="device">The desired device of returned tensor. Default: if None, the device of the input tensor is used.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, the element type of the input tensor is used.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, the backend of the input tensor is used.</param>
</member>
<member name="M:DiffSharp.dsharp.onehot(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a one-hot tensor, with one location set to 1, and all others 0.</summary>
 <param name="length">The length of the returned tensor.</param>
 <param name="hot">The location to set to 1.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.oneLike(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns the '0' scalar tensor with characteristics based on the input tensor.</summary>
 <param name="input">The shape and characteristics of input will determine those of the output tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, the device of the input tensor is used.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, the element type of the input tensor is used.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, the backend of the input tensor is used.</param>
</member>
<member name="M:DiffSharp.dsharp.one(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Get the scalar '1' tensor for the given configuration</summary>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.normalize(DiffSharp.Tensor)">
 <summary>Normalizes a vector so all the values are between zero and one (min-max scaling to 0..1).</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.noDiff(DiffSharp.Tensor)">
 <summary>Produce a new constant (non-differentiated) tensor.</summary>
 <param name="tensor">The input.</param>
</member>
<member name="M:DiffSharp.dsharp.nllLoss(DiffSharp.Tensor,DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>The negative log likelihood loss.</summary>
 <param name="input">The input tensor.</param>
 <param name="target">The target tensor.</param>
 <param name="weight">A optional manual rescaling weight given to the loss of each batch element.</param>
 <param name="reduction">Optionally specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: size_average and reduce are in the process of being deprecated, and in the meantime, specifying either of those two args will override reduction. Default: 'mean'.</param>
</member>
<member name="M:DiffSharp.dsharp.nestReset">
 <summary>Reset the global nesting level for automatic differentiation to zero.</summary>
</member>
<member name="M:DiffSharp.dsharp.nestLevel">
 <summary>Get the global nesting level for automatic differentiation.</summary>
</member>
<member name="M:DiffSharp.dsharp.nest(System.UInt32)">
 <summary>Set the global nesting level for automatic differentiation.</summary>
 <param name="level">The new nesting level.</param>
</member>
<member name="M:DiffSharp.dsharp.nest">
 <summary>Increase the global nesting level for automatic differentiation.</summary>
</member>
<member name="M:DiffSharp.dsharp.nelement(DiffSharp.Tensor)">
 <summary>Returns the total number of elements in the input tensor.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.neg(DiffSharp.Tensor)">
 <summary>Return the element-wise negation of the input tensor.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.ne(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Returns a boolean tensor for the element-wise non-equality comparison of the elements in the two tensors.</summary>
 <remarks>The shapes of input and other don’t need to match, but they must be broadcastable.</remarks>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.multinomial(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a tensor where each row contains numSamples indices sampled from the multinomial probability distribution located in the corresponding row of tensor input.</summary>
 <param name="probs">The input tensor containing probabilities.</param>
 <param name="numSamples">The number of samples to draw.</param>
 <param name="normalize">Indicates where the probabilities should first be normalized by their sum.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.mul(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Return the element-wise multiplication of the two tensors.</summary>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.mseLoss(DiffSharp.Tensor,DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>Creates a criterion that measures the mean squared error (squared L2 norm) between each element in the input and the target.</summary>
 <param name="input">The input tensor.</param>
 <param name="target">The target tensor.</param>
 <param name="reduction">Optionally specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: size_average and reduce are in the process of being deprecated, and in the meantime, specifying either of those two args will override reduction. Default: 'mean'.</param>
</member>
<member name="M:DiffSharp.dsharp.move(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Move the tensor to a difference device, backend and/or change its element type.</summary>
 <remarks>If the characteristics are unchanged the input tensor will be returned.</remarks>
 <param name="input">The input tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, the device of the input tensor is used.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, the element type of the input tensor is used.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, the backend of the input tensor is used.</param>
</member>
<member name="M:DiffSharp.dsharp.min(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the minimum value of all elements in the input tensor along the given dimension.</summary>
 <param name="a">The tensor.</param>
 <param name="dim">The dimension.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
</member>
<member name="M:DiffSharp.dsharp.min(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Each element of the tensor input is compared with the corresponding element of the tensor other and an element-wise minimum is taken.</summary>
 <remarks>The shapes of input and other don’t need to match, but they must be broadcastable.</remarks>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.min(DiffSharp.Tensor)">
 <summary>Returns the minimum value of all elements in the input tensor.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.mean(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the mean value of each row of the input tensor in the given dimension dim. If dim is a list of dimensions, reduce over all of them.</summary>
 <remarks>
  If keepdim is true, the output tensor is of the same size as input except in the dimension(s) dim where it is of size 1. Otherwise, dim is squeezed, resulting in the output tensor having 1 (or len(dim)) fewer dimension(s).
 </remarks>
 <param name="input">The input tensor.</param>
 <param name="dim">The dimension to reduce.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
</member>
<member name="M:DiffSharp.dsharp.mean(DiffSharp.Tensor)">
 <summary>Returns the mean value of all elements in the input tensor.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.maxunpool3d(DiffSharp.Tensor,DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Computes a partial inverse of maxpool3di</summary>
 <param name="input">The input tensor.</param>
 <param name="indices">The indices selected by maxpool3di.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSizes.</param>
 <param name="paddings">The implicit zero paddings to be added on corresponding sides.</param>
 <param name="outputSize">The targeted output size.</param>
</member>
<member name="M:DiffSharp.dsharp.maxunpool2d(DiffSharp.Tensor,DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Computes a partial inverse of maxpool2di</summary>
 <param name="input">The input tensor.</param>
 <param name="indices">The indices selected by maxpool2di.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSizes.</param>
 <param name="paddings">The implicit zero paddings to be added on corresponding sides.</param>
 <param name="outputSize">The targeted output size.</param>
</member>
<member name="M:DiffSharp.dsharp.maxunpool1d(DiffSharp.Tensor,DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Computes a partial inverse of maxpool1di</summary>
 <param name="input">The input tensor.</param>
 <param name="indices">The indices selected by maxpool1di.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="outputSize">The targeted output size.</param>
</member>
<member name="M:DiffSharp.dsharp.maxpool3di(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 3D max pooling over an input signal composed of several input planes, returning the max indices along with the outputs.</summary>
 <param name="input">The input tensor.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSize.</param>
 <param name="paddings">The implicit zero paddings to be added on corresponding sides.</param>
</member>
<member name="M:DiffSharp.dsharp.maxpool3d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 3D max pooling over an input signal composed of several input planes.</summary>
 <param name="input">The input tensor.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSizes.</param>
 <param name="paddings">The implicit zero paddings to be added on corresponding sides.</param>
</member>
<member name="M:DiffSharp.dsharp.maxpool2di(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 2D max pooling over an input signal composed of several input planes, returning the max indices along with the outputs.</summary>
 <param name="input">The input tensor.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSize.</param>
 <param name="paddings">The implicit zero paddings to be added on corresponding sides.</param>
</member>
<member name="M:DiffSharp.dsharp.maxpool2d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 2D max pooling over an input signal composed of several input planes.</summary>
 <param name="input">The input tensor.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSize.</param>
 <param name="paddings">The implicit zero paddings to be added on corresponding sides.</param>
</member>
<member name="M:DiffSharp.dsharp.maxpool1di(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Applies a 1D max pooling over an input signal composed of several input planes, returning the max indices along with the outputs.</summary>
 <param name="input">The input tensor.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
</member>
<member name="M:DiffSharp.dsharp.maxpool1d(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Applies a 1D max pooling over an input signal composed of several input planes.</summary>
 <param name="input">The input tensor.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
</member>
<member name="M:DiffSharp.dsharp.max(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the maximum value of all elements in the input tensor along the given dimension.</summary>
 <param name="a">The tensor.</param>
 <param name="dim">The dimension.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
</member>
<member name="M:DiffSharp.dsharp.max(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Each element of the tensor input is compared with the corresponding element of the tensor other and an element-wise maximum is taken.</summary>
 <remarks>The shapes of input and other don’t need to match, but they must be broadcastable.</remarks>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.max(DiffSharp.Tensor)">
 <summary>Returns the maximum value of all elements in the input tensor.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.matmul(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Matrix product of two tensors.</summary>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.mapi3(Microsoft.FSharp.Core.FSharpFunc{System.Int32[],Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor}}}},DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Produce a new tensor by mapping a function over all corresponding elements of three input tensors.</summary>
 <remarks>The function is passed the index of each element. The shapes of the three tensors must be identical.</remarks>
 <param name="mapping">The function to apply to each element of the tensor.</param>
 <param name="tensor1">The first input tensor.</param>
 <param name="tensor2">The second input tensor.</param>
 <param name="tensor3">The third input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.mapi2(Microsoft.FSharp.Core.FSharpFunc{System.Int32[],Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor}}},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Produce a new tensor by mapping a function over all corresponding elements of two input tensors.</summary>
 <remarks>The function is passed the index of each element. The shapes of the two tensors must be identical.</remarks>
 <param name="mapping">The function to apply to each element of the tensor.</param>
 <param name="tensor1">The first input tensor.</param>
 <param name="tensor2">The second input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.mapi(Microsoft.FSharp.Core.FSharpFunc{System.Int32[],Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor}},DiffSharp.Tensor)">
 <summary>Produce a new tensor by mapping a function over all elements of the input tensor.</summary>
 <param name="mapping">The function is passed the index of each element. The function to apply to each element of the tensor.</param>
 <param name="tensor">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.map3(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor}}},DiffSharp.Tensor,DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Produce a new tensor by mapping a function over all corresponding elements of three input tensors.</summary>
 <remarks>The shapes of the three tensors must be identical.</remarks>
 <param name="mapping">The function to apply to each element of the tensor.</param>
 <param name="tensor1">The first input tensor.</param>
 <param name="tensor2">The second input tensor.</param>
 <param name="tensor3">The third input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.map2(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor}},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Produce a new tensor by mapping a function over all corresponding elements of two input tensors.</summary>
 <remarks>The shapes of the two tensors must be identical.</remarks>
 <param name="mapping">The function to apply to each element of the tensor.</param>
 <param name="tensor1">The first input tensor.</param>
 <param name="tensor2">The second input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.map(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>Produce a new tensor by mapping a function over all elements of the input tensor.</summary>
 <param name="mapping">The function to apply to each element of the tensor.</param>
 <param name="tensor">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.lt(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Returns a boolean tensor for the element-wise less-than comparison of the elements in the two tensors.</summary>
 <remarks>The shapes of input and other don’t need to match, but they must be broadcastable.</remarks>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.logsumexp(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Applies a logsumexp followed by a logarithm.</summary>
 <param name="input">The input tensor.</param>
 <param name="dim">The dimension to reduce.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
</member>
<member name="M:DiffSharp.dsharp.logspace(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>
 Returns a 1-D tensor of size <paramref name="steps"/> whose values are evenly spaced logarithmically from \(\text{baseVal}^{\text{startVal}}\) to \(\text{baseVal}^{\text{endVal}}\). The values are going to be: \(
 (\text{baseVal}^{\text{startVal}},
 \text{baseVal}^{(\text{startVal} + \frac{\text{endVal} - \text{startVal}}{ \text{steps} - 1})},
 \ldots,
 \text{baseVal}^{(\text{startVal} + (\text{steps} - 2) * \frac{\text{endVal} - \text{startVal}}{ \text{steps} - 1})},
 \text{baseVal}^{\text{endVal}})
 \)
 </summary>
 <param name="startVal">The starting value for the set of points.</param>
 <param name="endVal">The ending value for the set of points.</param>
 <param name="steps">The size of the returned tensor.</param>
 <param name="baseVal">The base of the logarithm. Default: 10.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.logspace(System.Double,System.Double,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>
 Returns a 1-D tensor of size <paramref name="steps"/> whose values are evenly spaced logarithmically from \(\text{baseVal}^{\text{startVal}}\) to \(\text{baseVal}^{\text{endVal}}\). The values are going to be: \(
 (\text{baseVal}^{\text{startVal}},
 \text{baseVal}^{(\text{startVal} + \frac{\text{endVal} - \text{startVal}}{ \text{steps} - 1})},
 \ldots,
 \text{baseVal}^{(\text{startVal} + (\text{steps} - 2) * \frac{\text{endVal} - \text{startVal}}{ \text{steps} - 1})},
 \text{baseVal}^{\text{endVal}})
 \)
 </summary>
 <param name="startVal">The starting value for the set of points.</param>
 <param name="endVal">The ending value for the set of points.</param>
 <param name="steps">The size of the returned tensor.</param>
 <param name="baseVal">The base of the logarithm. Default: 10.0.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.logsoftmax(DiffSharp.Tensor,System.Int32)">
 <summary>Applies a softmax followed by a logarithm.</summary>
 <param name="input">The input tensor.</param>
 <param name="dim">A dimension along which softmax will be computed.</param>
</member>
<member name="M:DiffSharp.dsharp.log10(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the logarithm to the base 10 of the elements of input.</summary>
 <remarks>\[y_{i} = \log_{10} (x_{i})\]</remarks>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.log(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the natural logarithm of the elements of input.</summary>
 <remarks> \[y_{i} = \log_{e} (x_{i})\]</remarks>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.load``1(System.String)">
 <summary>Loads an object from the given file using a bespoke binary format.</summary>
 <remarks>
   The format used may change from version to version of DiffSharp.
 </remarks>
</member>
<member name="M:DiffSharp.dsharp.linspace(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>
 Returns a 1-D tensor of size <paramref name="steps"/> whose values are evenly spaced from <paramref name="startVal"/> to <paramref name="endVal"/>. The values are going to be: \(
 (\text{startVal},
 \text{startVal} + \frac{\text{endVal} - \text{startVal}}{\text{steps} - 1},
 \ldots,
 \text{startVal} + (\text{steps} - 2) * \frac{\text{endVal} - \text{startVal}}{\text{steps} - 1},
 \text{endVal}) 
 \)
 </summary>
 <param name="startVal">The starting value for the set of points.</param>
 <param name="endVal">The ending value for the set of points.</param>
 <param name="steps">The size of the returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.linspace(System.Double,System.Double,System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>
 Returns a 1-D tensor of size <paramref name="steps"/> whose values are evenly spaced from <paramref name="startVal"/> to <paramref name="endVal"/>. The values are going to be: \(
 (\text{startVal},
 \text{startVal} + \frac{\text{endVal} - \text{startVal}}{\text{steps} - 1},
 \ldots,
 \text{startVal} + (\text{steps} - 2) * \frac{\text{endVal} - \text{startVal}}{\text{steps} - 1},
 \text{endVal}) 
 \)
 </summary>
 <param name="startVal">The starting value for the set of points.</param>
 <param name="endVal">The ending value for the set of points.</param>
 <param name="steps">The size of the returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.like(DiffSharp.Tensor,System.Object,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new tensor based on the given .NET value with characteristics based on the input tensor.</summary>
 <param name="input">The shape and characteristics of input will determine those of the output tensor.</param>
 <param name="value">The .NET object giving the the initial values for the tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, the device of the input tensor is used.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, the element type of the input tensor is used.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, the backend of the input tensor is used.</param>
</member>
<member name="M:DiffSharp.dsharp.leakyRelu(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>Applies the leaky rectified linear unit function element-wise</summary>
 <remarks>\[\text{LeakyReLU}(x) = \max(0, x) + \text{negative\_slope} * \min(0, x)\]</remarks>
 <param name="input">The input tensor.</param>
 <param name="negativeSlope">Controls the angle of the negative slope. Default: 0.01.</param>
</member>
<member name="M:DiffSharp.dsharp.le(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Return a boolean tensor for the element-wise less-than-or-equal comparison of the elements in the two tensors.</summary>
 <remarks>The shapes of input and other don’t need to match, but they must be broadcastable.</remarks>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.laplacian(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.jacobianv(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.jacobianTv(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Transposed Jacobian-vector product of a vector-to-vector function `f`, at point `x`, along vector `v`</summary>
 <param name="f">vector-to-vector function</param>
 <param name="x">Point at which the function <c>f</c> will be evaluated, it must have a single dimension.</param>
 <param name="v">Vector</param>
</member>
<member name="M:DiffSharp.dsharp.jacobian(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.isnan(DiffSharp.Tensor)">
 <summary>Returns a boolean tensor where each element indicates if the corresponding element in the input tensor is a NaN (not-a-number) value.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.isinf(DiffSharp.Tensor)">
 <summary>Returns a boolean tensor where each element indicates if the corresponding element in the input tensor is an infinity value.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.isTensor(System.Object)">
 <summary>Indicates if an object is a tensor</summary>
</member>
<member name="M:DiffSharp.dsharp.isDeviceTypeAvailable(DiffSharp.DeviceType,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Indicates if a given device type is available for a given backend.</summary>
 <param name="deviceType">The requested device type.</param>
 <param name="backend">Return information for this backend. Defaults to Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.isDeviceAvailable(DiffSharp.Device,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Indicates if a given device is available for a given backend.</summary>
 <param name="device">The requested device.</param>
 <param name="backend">Return information for this backend. Defaults to Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.isCudaAvailable(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Indicates if CUDA is available for a given backend.</summary>
 <param name="backend">Return information for this backend. Defaults to Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.isBackendAvailable(DiffSharp.Backend)">
 <summary>Indicates if a given backend is available.</summary>
</member>
<member name="M:DiffSharp.dsharp.init4d``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}}}})">
 <summary>Create a new 4D tensor using the given initializer for each element.</summary>
 <param name="length1">The length of the tensor in the 1st dimension.</param>
 <param name="length2">The length of the tensor in the 2nd dimension.</param>
 <param name="length3">The length of the tensor in the 3rd dimension.</param>
 <param name="length4">The length of the tensor in the 4th dimension.</param>
 <param name="initializer">The function used to initialize each element.</param>
</member>
<member name="M:DiffSharp.dsharp.init3d``1(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}}})">
 <summary>Create a new 3D tensor using the given initializer for each element.</summary>
 <param name="length1">The length of the tensor in the 1st dimension.</param>
 <param name="length2">The length of the tensor in the 2nd dimension.</param>
 <param name="length3">The length of the tensor in the 3rd dimension.</param>
 <param name="initializer">The function used to initialize each element.</param>
</member>
<member name="M:DiffSharp.dsharp.init2d``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0}})">
 <summary>Create a new 2D tensor using the given initializer for each element.</summary>
 <param name="length1">The length of the tensor in the first dimension.</param>
 <param name="length2">The length of the tensor in the second dimension.</param>
 <param name="initializer">The function used to initialize each element.</param>
</member>
<member name="M:DiffSharp.dsharp.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
 <summary>Create a new 1D tensor using the given initializer for each element.</summary>
 <param name="count">The length of the tensor.</param>
 <param name="initializer">The function used to initialize each element.</param>
</member>
<member name="M:DiffSharp.dsharp.hessianv(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.hessian(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.hasnan(DiffSharp.Tensor)">
 <summary>Returns a boolean indicating if any element of the tensor is a not-a-number (NaN) value.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.hasinf(DiffSharp.Tensor)">
 <summary>Returns a boolean indicating if any element of the tensor is infinite.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.gt(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Returns a boolean tensor for the element-wise greater-than comparison of the elements in the two tensors.</summary>
 <remarks>The shapes of input and other don’t need to match, but they must be broadcastable.</remarks>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.gradv(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.gradhessianv(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.gradhessian(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.grad(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.dsharp.version">
 <summary>Returns the version of the DiffSharp.Core assembly.</summary>
</member>
<member name="M:DiffSharp.dsharp.ge(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Returns a boolean tensor for the element-wise greater-than-or-equal comparison of the elements in the two tensors.</summary>
 <remarks>The shapes of input and other don’t need to match, but they must be broadcastable.</remarks>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.gather(DiffSharp.Tensor,System.Int32,DiffSharp.Tensor)">
 <summary>Gathers values along an axis specified by dim.</summary>
 <param name="input">The input tensor.</param>
 <param name="dim">The axis along which to index.</param>
 <param name="indices">The the indices of elements to gather.</param>
</member>
<member name="M:DiffSharp.dsharp.fullLike(DiffSharp.Tensor,System.IConvertible,Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new tensor filled with the given scalar value with characteristics based on the input tensor.</summary>
 <param name="input">The shape and characteristics of input will determine those of the output tensor.</param>
 <param name="value">The scalar giving the the initial values for the tensor.</param>
 <param name="shape">The desired shape of returned tensor. Default: If None, the shape of the input tensor is used.</param>
 <param name="device">The desired device of returned tensor. Default: if None, the device of the input tensor is used.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, the element type of the input tensor is used.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, the backend of the input tensor is used.</param>
</member>
<member name="M:DiffSharp.dsharp.full(System.Int32,System.IConvertible,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new tensor of the given length filled with <paramref name="value" />, for the given element type and configuration</summary>
 <param name="length">The length of the returned tensor.</param>
 <param name="value">The scalar giving the the initial values for the tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.full(System.Collections.Generic.IEnumerable{System.Int32},System.IConvertible,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new tensor filled with the scalar <paramref name="value" />, for the given shape, element type and configuration</summary>
 <param name="shape">The desired shape of returned tensor.</param>
 <param name="value">The scalar used to form the initial values for the tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.forwardDiff(System.UInt32,DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Produce a new tensor suitable for calculating the forward-mode derivative at the given level tag.</summary>
 <param name="nestingTag">The level tag.</param>
 <param name="derivative">The derivative of the input.</param>
 <param name="tensor">The input.</param>
</member>
<member name="M:DiffSharp.dsharp.floor(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the floor of the elements of input, the largest integer less than or equal to each element.</summary>
 <remarks>The tensor will have the same element type as the input tensor.</remarks>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.flip(DiffSharp.Tensor,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Reverse the order of a n-D tensor along given axis in dims</summary>
 <param name="input">The input tensor.</param>
 <param name="dims">The axis to flip on.</param>
</member>
<member name="M:DiffSharp.dsharp.flatten(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Flattens a contiguous range of dims in a tensor.</summary>
 <param name="input">The input tensor.</param>
 <param name="startDim">The first dim to flatten.</param>
 <param name="endDim">The last dim to flatten.</param>
</member>
<member name="M:DiffSharp.dsharp.flaplacian(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.fjacobianv(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
 <param name="f">TBD</param>
 <param name="x">TBD</param>
 <param name="v">TBD</param>
 <remarks>The <c>x</c> and <c>v</c> tensors should have the same number of elements.</remarks>
</member>
<member name="M:DiffSharp.dsharp.fjacobianTv(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Original value and transposed Jacobian-vector product of a vector-to-vector function `f`, at point `x`, along vector `v`</summary>
 <param name="f">vector-to-vector function</param>
 <param name="x">Point at which the function <c>f</c> will be evaluated, it must have a single dimension.</param>
 <param name="v">Vector</param>
</member>
<member name="M:DiffSharp.dsharp.fjacobian(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.fhessianv(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.fhessian(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.fgradv(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
 <param name="f">TBD</param>
 <param name="x">TBD</param>
 <param name="v">TBD</param>
 <remarks>The <c>x</c> and <c>v</c> tensors should have the same number of elements.</remarks>
</member>
<member name="M:DiffSharp.dsharp.fgradhessianv(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.fgradhessian(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.fgrad(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.ffdiffn(System.Int32,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.fdivergence(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.fdiffn(System.Int32,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.fdiff2(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.fdiff(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.fcurldivergence(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.fcurl(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.eye(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a 2-D tensor with ones on the diagonal and zeros elsewhere.</summary>
 <param name="rows">The number of rows</param>
 <param name="cols">The number of columns with default being n</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.expandAs(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Expand the input tensor to the same size as other tensor</summary>
 <param name="input">The input tensor.</param>
 <param name="other">The result tensor has the same size as other.</param>
</member>
<member name="M:DiffSharp.dsharp.expand(DiffSharp.Tensor,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Returns a new view of the input tensor with singleton dimensions expanded to a larger size</summary>
 <param name="input">The input tensor.</param>
 <param name="shape">The desired shape of returned tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.exp(DiffSharp.Tensor)">
 <summary>Applies the exp function element-wise.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.evalReverseDiff(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.evalForwardDiffs(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor[])">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.evalForwardDiff(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.eq(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Returns a boolean tensor for the element-wise equality comparison of the elements in the two tensors.</summary>
 <remarks>The shapes of input and other don’t need to match, but they must be broadcastable.</remarks>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.empty(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new empty tensor holding no data, for the given element type and configuration</summary>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.empty(System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new uninitialized tensor filled with arbitrary values for the given length, element type and configuration</summary>
 <param name="length">The length of the returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.empty(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Returns a new uninitialized tensor filled with arbitrary values for the given shape, element type and configuration</summary>
 <param name="shape">The desired shape of returned tensor.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.dropout3d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>Randomly zero out entire channels (a channel is a 3D feature map, e.g., the jj -th channel of the ii -th sample in the batched input is a 3D tensor \text{input}[i, j]input[i,j] ). Each channel will be zeroed out independently on every forward call with probability p using samples from a Bernoulli distribution.</summary>
 <param name="input">The input tensor.</param>
 <param name="p">The probability of an element to be zeroed. Default: 0.5.</param>
</member>
<member name="M:DiffSharp.dsharp.dropout2d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>Randomly zero out entire channels (a channel is a 2D feature map, e.g., the jj -th channel of the ii -th sample in the batched input is a 2D tensor \text{input}[i, j]input[i,j] ). Each channel will be zeroed out independently on every forward call with probability p using samples from a Bernoulli distribution</summary>
 <param name="input">The input tensor.</param>
 <param name="p">The probability of an element to be zeroed. Default: 0.5.</param>
</member>
<member name="M:DiffSharp.dsharp.dropout(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>Randomly zeroes some of the elements of the input tensor with probability p using samples from a Bernoulli distribution</summary>
 <param name="input">The input tensor.</param>
 <param name="p">The probability of an element to be zeroed. Default: 0.5.</param>
</member>
<member name="M:DiffSharp.dsharp.dot(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Computes the dot product (inner product) of two tensors.</summary>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.divergence(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.div(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Return the element-wise division of the two tensors.</summary>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.dilate(DiffSharp.Tensor,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>Dilate the tensor in using the given dilations in each corresponding dimension.</summary>
 <param name="input">The input tensor.</param>
 <param name="dilations">The dilations to use.</param>
</member>
<member name="M:DiffSharp.dsharp.diffn(System.Int32,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.diff2(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.diff(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.diagonal(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
  Returns a tensor with the diagonal elements with respect to <c>dim1</c> and <c>dim2</c>.
  The argument offset controls which diagonal to consider.
 </summary>
 <param name="input">The input tensor. Must be at least 2-dimensional.</param>
 <param name="offset">Which diagonal to consider. Default: 0.</param>
 <param name="dim1">The first dimension with respect to which to take diagonal. Default: 0..</param>
 <param name="dim2">The second dimension with respect to which to take diagonal. Default: 1.</param>
</member>
<member name="M:DiffSharp.dsharp.devices(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend},Microsoft.FSharp.Core.FSharpOption{DiffSharp.DeviceType})">
 <summary>Returns the list of available devices for a given backend.</summary>
 <param name="backend">Return information for this backend. Defaults to Backend.Default.</param>
 <param name="deviceType">If given, only return devices for this device type.</param>
</member>
<member name="M:DiffSharp.dsharp.derivative(DiffSharp.Tensor)">
 <summary>Get the derivative value of the tensor.</summary>
</member>
<member name="M:DiffSharp.dsharp.curldivergence(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.curl(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.dsharp.crossEntropyLoss(DiffSharp.Tensor,DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>This criterion combines logsoftmax and nllLoss in a single function</summary>
 <param name="input">The input tensor.</param>
 <param name="target">The target tensor.</param>
 <param name="weight">A optional manual rescaling weight given to the loss of each batch element.</param>
 <param name="reduction">Optionally specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: size_average and reduce are in the process of being deprecated, and in the meantime, specifying either of those two args will override reduction. Default: 'mean'.</param>
</member>
<member name="M:DiffSharp.dsharp.create``1(System.Int32,``0)">
 <summary>Create a new 1D tensor using the given value for each element.</summary>
 <param name="count">The number of elements in the tensor.</param>
 <param name="value">The initial value for each element of the tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.cov(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int64},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor})">
 <summary>
 Estimates the covariance matrix of the given tensor. The tensor's first
 dimension should index variables and the second dimension should
 index observations for each variable.
 </summary>
 <remarks>
 If no weights are given, the covariance between variables \(x\) and \(y\) is
  \[cov(x,y)= \frac{\sum^{N}_{i = 1}(x_{i} - \mu_x)(y_{i} - \mu_y)}{N~-~\text{correction}}\]
 where \(\mu_x\) and \(\mu_y\) are the sample means.
 
 If there are fweights or aweights then the covariance is
 \[cov(x,y)=\frac{\sum^{N}_{i = 1}w_i(x_{i} - \mu_x^*)(y_{i} - \mu_y^*)}{\text{normalization factor}}\]
 where \(w\) is either fweights or aweights if one weight type is provided.
 If both weight types are provided \(w=\text{fweights}\times\text{aweights}\). 
 \(\mu_x^* = \frac{\sum^{N}_{i = 1}w_ix_{i} }{\sum^{N}_{i = 1}w_i}\)
 is the weighted mean of variables.
 The normalization factor is \(\sum^{N}_{i=1} w_i\) if only fweights are provided or if aweights are provided and <c>correction=0</c>. 
 Otherwise if aweights \(aw\) are provided the normalization factor is
  \(\sum^N_{i=1} w_i - \text{correction}\times\frac{\sum^N_{i=1} w_i aw_i}{\sum^N_{i=1} w_i}\) 
 </remarks>
 <param name="input">The input tensor.</param>
 <param name="correction">Difference between the sample size and the sample degrees of freedom. Defaults to 1 (Bessel's correction).</param>
 <param name="fweights">Frequency weights represent the number of times each observation was observed. 
 Should be given as a tensor of integers. Defaults to no weights.</param>
 <param name="aweights">Relative importance weights, larger weights for observations that
 should have a larger effect on the estimate. 
 Should be given as a tensor of floating point numbers. Defaults to no weights.</param>
 <returns>Returns a square tensor representing the covariance matrix.
  Given a tensor with \(N\) variables \(X=[x_1,x_2,\ldots,x_N]\) the
 \(C_{i,j}\) entry on the covariance matrix is the covariance between
 \(x_i\) and \(x_j\).
 </returns>
 <example id="tensor-covariance1">
 <code lang="fsharp">
 let x = dsharp.tensor([0.0;3.4;5.0])
 let y = dsharp.tensor([1.0;2.3;-3.0])
 let xy = dsharp.stack([x;y])
 xy.cov()
 </code>
 Evaluates to
 <code>
 tensor([[ 6.5200, -4.0100],
         [-4.0100,  7.6300]])
 </code>
 </example>
</member>
<member name="M:DiffSharp.dsharp.cosh(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the hyperbolic cosine of the elements of input.</summary>
</member>
<member name="M:DiffSharp.dsharp.cos(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the cosine of the elements of input</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.corrcoef(DiffSharp.Tensor)">
 <summary>
 Estimates the Pearson correlation coefficient matrix for the given tensor. The tensor's first
 dimension should index variables and the second dimension should
 index observations for each variable.
 </summary>
 <returns>
 The correlation coefficient matrix \(R\) is computed from the covariance
 matrix 
 Returns a square tensor representing the correlation coefficient matrix.
  Given a tensor with \(N\) variables \(X=[x_1,x_2,\ldots,x_N]\) the
 \(R_{i,j}\) entry on the correlation matrix is the correlation between
 \(x_i\) and \(x_j\).
 </returns>
 <remarks>
 The correlation between variables \(x\) and \(y\) is
  \[cor(x,y)= \frac{\sum^{N}_{i = 1}(x_{i} - \mu_x)(y_{i} - \mu_y)}{\sigma_x \sigma_y (N ~-~1)}\]
 where \(\mu_x\) and \(\mu_y\) are the sample means and \(\sigma_x\) and \(\sigma_x\) are 
 the sample standard deviations.
 </remarks>
 <param name="input">The input tensor.</param>
 <example id="tensor-correlation1">
 <code lang="fsharp">
 let x = dsharp.tensor([-0.2678; -0.0908; -0.3766;  0.2780])
 let y = dsharp.tensor([-0.5812;  0.1535;  0.2387;  0.2350])
 let xy = dsharp.stack([x;y])
 dsharp.corrcoef(xy)
 </code>
 Evaluates to
 <code>
 tensor([[1.0000, 0.3582],
         [0.3582, 1.0000]])
 </code>
 </example>
</member>
<member name="M:DiffSharp.dsharp.convTranspose3d(DiffSharp.Tensor,DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 3D transposed convolution operator over an input signal composed of several input planes, sometimes also called 'deconvolution'.</summary>
 <param name="input">The input tensor.</param>
 <param name="filters">The filters.</param>
 <param name="stride">The stride of the convolving kernel.</param>
 <param name="padding">The implicit padding on both sides of the input.</param>
 <param name="dilation">The spacing between kernel elements.</param>
 <param name="strides">The strides of the convolving kernel.</param>
 <param name="paddings">The implicit paddings on corresponding sides of the input.</param>
 <param name="dilations">The spacings between kernel elements.</param>
 <param name="outputPadding">The additional size added to one side of each dimension in the output shape.</param>
 <param name="outputPaddings">The additional sizes added to one side of each dimension in the output shape.</param>
</member>
<member name="M:DiffSharp.dsharp.convTranspose2d(DiffSharp.Tensor,DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 2D transposed convolution operator over an input signal composed of several input planes, sometimes also called 'deconvolution'.</summary>
 <param name="input">The input tensor.</param>
 <param name="filters">The filters.</param>
 <param name="stride">The stride of the convolving kernel.</param>
 <param name="padding">The implicit padding on both sides of the input.</param>
 <param name="dilation">The spacing between kernel elements.</param>
 <param name="strides">The strides of the convolving kernel.</param>
 <param name="paddings">The implicit paddings on corresponding sides of the input.</param>
 <param name="dilations">The spacings between kernel elements.</param>
 <param name="outputPadding">The additional size added to one side of each dimension in the output shape.</param>
 <param name="outputPaddings">The additional sizes added to one side of each dimension in the output shape.</param>
</member>
<member name="M:DiffSharp.dsharp.convTranspose1d(DiffSharp.Tensor,DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Applies a 1D transposed convolution operator over an input signal composed of several input planes, sometimes also called 'deconvolution'.</summary>
 <param name="input">The input tensor.</param>
 <param name="filters">The filters.</param>
 <param name="stride">The stride of the convolving kernel.</param>
 <param name="padding">The implicit padding on both sides of the input.</param>
 <param name="dilation">The spacing between kernel elements.</param>
 <param name="outputPadding">The additional size added to one side of each dimension in the output shape.</param>
</member>
<member name="M:DiffSharp.dsharp.conv3d(DiffSharp.Tensor,DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 3D convolution over an input signal composed of several input planes</summary>
 <param name="input">The input tensor.</param>
 <param name="filters">The filters.</param>
 <param name="stride">The stride of the convolving kernel.</param>
 <param name="padding">The implicit padding on corresponding sides of the input.</param>
 <param name="dilation">The spacing between kernel elements.</param>
 <param name="strides">The strides of the convolving kernel.</param>
 <param name="paddings">The implicit paddings on corresponding sides of the input.</param>
 <param name="dilations">The spacings between kernel elements.</param>
</member>
<member name="M:DiffSharp.dsharp.conv2d(DiffSharp.Tensor,DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 2D convolution over an input signal composed of several input planes</summary>
 <param name="input">The input tensor.</param>
 <param name="filters">The filters.</param>
 <param name="stride">The stride of the convolving kernel.</param>
 <param name="padding">The implicit padding on corresponding sides of the input.</param>
 <param name="dilation">The spacing between kernel elements.</param>
 <param name="strides">The strides of the convolving kernel.</param>
 <param name="paddings">The implicit paddings on corresponding sides of the input.</param>
 <param name="dilations">The spacings between kernel elements.</param>
</member>
<member name="M:DiffSharp.dsharp.conv1d(DiffSharp.Tensor,DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Applies a 1D convolution over an input signal composed of several input planes</summary>
 <param name="input">The input tensor.</param>
 <param name="filters">The filters.</param>
 <param name="stride">The stride of the convolving kernel.</param>
 <param name="padding">The implicit paddings on both sides of the input.</param>
 <param name="dilation">The spacing between kernel elements.</param>
</member>
<member name="M:DiffSharp.dsharp.config(System.Tuple{DiffSharp.Device,DiffSharp.Dtype,DiffSharp.Backend,DiffSharp.Printer})">
 <summary>Configure the default device, element type, backend, printer. Only floating point dtypes are supported as the default.</summary>
 <param name="configuration">A tuple of the new default device, default element type, default backend, and default printer.</param>
</member>
<member name="M:DiffSharp.dsharp.config">
 <summary>Return the current default device, element type, backend, and printer.</summary>
</member>
<member name="M:DiffSharp.dsharp.config(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Printer})">
 <summary>Configure the default device, dtype, and/or backend.</summary>
 <param name="device">The new default device.</param>
 <param name="dtype">The new default element type. Only floating point dtypes are supported as the default.</param>
 <param name="backend">The new default backend.</param>
 <param name="printer">The new default printer.</param>
</member>
<member name="M:DiffSharp.dsharp.clone(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the same characteristics and storage cloned.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.clamp(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.IConvertible},Microsoft.FSharp.Core.FSharpOption{System.IConvertible})">
 <summary>Clamp all elements in input into the range [ low..high] and return a resulting tensor</summary>
 <param name="input">The input tensor.</param>
 <param name="low">The lower-bound of the range to be clamped to.</param>
 <param name="high">The upper-bound of the range to be clamped to.</param>
</member>
<member name="M:DiffSharp.dsharp.ceil(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the ceil of the elements of input, the smallest integer greater than or equal to each element.</summary>
 <remarks>The tensor will have the same element type as the input tensor.</remarks>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.cat(System.Collections.Generic.IEnumerable{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Concatenates the given sequence of seq tensors in the given dimension. All tensors must either have the same shape (except in the concatenating dimension) or be empty.</summary>
 <param name="tensors">The sequence of tensors to concatenate.</param>
 <param name="dim">The the dimension over which the tensors are concatenated.</param>
</member>
<member name="M:DiffSharp.dsharp.cast(DiffSharp.Tensor,DiffSharp.Dtype)">
 <summary>Convert the tensor to one with the given element type.</summary>
 <remarks>If the element type is unchanged the input tensor will be returned.</remarks>
 <param name="input">The input tensor.</param>
 <param name="dtype">The desired element type of returned tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.bernoulli(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Draws binary random numbers (0 or 1) from a Bernoulli distribution</summary>
 <param name="probs">The input tensor of probability values for the Bernoulli distribution.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.bceLoss(DiffSharp.Tensor,DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>Creates a criterion that measures the Binary Cross Entropy between the target and the output</summary>
 <param name="input">The input tensor.</param>
 <param name="target">The target tensor.</param>
 <param name="weight">A manual rescaling weight given to the loss of each batch element.</param>
 <param name="reduction">Optionally specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: size_average and reduce are in the process of being deprecated, and in the meantime, specifying either of those two args will override reduction. Default: 'mean'.</param>
</member>
<member name="M:DiffSharp.dsharp.backendsAndDevices">
 <summary>Returns the list of available backends and devices available for each backend.</summary>
</member>
<member name="M:DiffSharp.dsharp.backends">
 <summary>Returns the list of available backends.</summary>
</member>
<member name="M:DiffSharp.dsharp.atan(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the arctangent of the elements of input.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.asin(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the arcsine of the elements of input.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.argmin(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the indices of the minimum value of all elements in the input tensor.</summary>
 <param name="input">The input tensor.</param>
 <param name="dim">The dimension.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
</member>
<member name="M:DiffSharp.dsharp.argmin(DiffSharp.Tensor)">
 <summary>Returns the indices of the minimum value of all elements in the input tensor.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.argmax(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>Returns the indices of the maximum value of all elements in the input tensor.</summary>
 <param name="input">The input tensor.</param>
 <param name="dim">The dimension.</param>
 <param name="keepDim">Whether the output tensor has dim retained or not.</param>
</member>
<member name="M:DiffSharp.dsharp.argmax(DiffSharp.Tensor)">
 <summary>Returns the indices of the maximum value of all elements in the input tensor.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.arangeLike(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>
 A version of dsharp.arange with characteristics based on the input tensor.
 </summary>
 
 <param name="input">The shape and characteristics of input will determine those of the output tensor.</param>
 <param name="endVal">The ending value for the set of points.</param>
 <param name="startVal">The starting value for the set of points. Default: 0.</param>
 <param name="step">The gap between each pair of adjacent points. Default: 1.</param>
 <param name="device">The desired device of returned tensor. Default: if None, the device of the input tensor is used.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, the element type of the input tensor is used.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, the backend of the input tensor is used.</param>
</member>
<member name="M:DiffSharp.dsharp.arangeLike(DiffSharp.Tensor,System.Double,Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>
 A version of dsharp.arange with characteristics based on the input tensor.
 </summary>
 
 <param name="input">The shape and characteristics of input will determine those of the output tensor.</param>
 <param name="endVal">The ending value for the set of points.</param>
 <param name="startVal">The starting value for the set of points. Default: 0.</param>
 <param name="step">The gap between each pair of adjacent points. Default: 1.</param>
 <param name="device">The desired device of returned tensor. Default: if None, the device of the input tensor is used.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, the element type of the input tensor is used.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, the backend of the input tensor is used.</param>
</member>
<member name="M:DiffSharp.dsharp.arange(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>
 Returns a 1-D tensor of size \(\left\lceil \frac{\text{end} - \text{start}}{\text{step}} \right\rceil\)
 with values from the interval [start, end) taken with common difference step beginning from start.
 </summary>
 <param name="endVal">The ending value for the set of points.</param>
 <param name="startVal">The starting value for the set of points. Default: 0.</param>
 <param name="step">The gap between each pair of adjacent points. Default: 1.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.arange(System.Double,Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>
 Returns a 1-D tensor of size \(\left\lceil \frac{\text{end} - \text{start}}{\text{step}} \right\rceil\)
 with values from the interval [start, end) taken with common difference step beginning from start.
 </summary>
 
 <remarks>
  Non-integer steps may be subject to floating point rounding errors when comparing against end.
 </remarks>
 <param name="endVal">The ending value for the set of points.</param>
 <param name="startVal">The starting value for the set of points. Default: 0.</param>
 <param name="step">The gap between each pair of adjacent points. Default: 1.</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
</member>
<member name="M:DiffSharp.dsharp.add(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Return the element-wise addition of the two tensors.</summary>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.acos(DiffSharp.Tensor)">
 <summary>Returns a new tensor with the arccosine of the elements of input.</summary>
 <param name="input">The input tensor.</param>
</member>
<member name="M:DiffSharp.dsharp.abs(DiffSharp.Tensor)">
 <summary>Computes the element-wise absolute value of the given input tensor.</summary>
 <remarks>The tensor will have the same element type as the input tensor.</remarks>
</member>
<member name="T:DiffSharp.dsharp">
<summary>
 Tensor operations
</summary>
</member>
<member name="P:DiffSharp.BackendModule.Default">
<summary>
 Get or set the default backend used when creating tensors. Note, use &lt;c&gt;dsharp.config(...)&lt;/c&gt; instead.
</summary>
</member>
<member name="M:DiffSharp.BackendModule.Register(System.String)">
<summary>
 Register a new backend
</summary>
</member>
<member name="T:DiffSharp.BackendModule">
<summary>
 Contains functions and settings related to backend specifications.
</summary>
</member>
<member name="P:DiffSharp.DeviceModule.Default">
<summary>
 Get or set the default device used when creating tensors. Note, use &lt;c&gt;dsharp.config(...)&lt;/c&gt; instead.
</summary>
</member>
<member name="T:DiffSharp.DeviceModule">
<summary>
 Contains functions and settings related to device specifications.
</summary>
</member>
<member name="M:DiffSharp.DtypeModule.divisionType(DiffSharp.Dtype,DiffSharp.Dtype)">
<summary>
 Find the Dtype which would result from dividing tensors with dtype1 and dtype2
</summary>
</member>
<member name="P:DiffSharp.DtypeModule.Default">
<summary>
 Get or set the default element type used when creating tensors. Only floating point types are supported as the default type. Note, use &lt;c&gt;dsharp.config(...)&lt;/c&gt; instead.
</summary>
</member>
<member name="M:DiffSharp.DtypeModule.widen(DiffSharp.Dtype,DiffSharp.Dtype)">
<summary>
 Find the Dtype into which dtype1 and dtype2 can be widened
</summary>
</member>
<member name="M:DiffSharp.DtypeModule.|IntegralOrBool|_|(DiffSharp.Dtype)">
<summary>
 Matches all integral or boolean tensor element types
</summary>
</member>
<member name="M:DiffSharp.DtypeModule.|Integral|_|(DiffSharp.Dtype)">
<summary>
 Matches all integral tensor element types
</summary>
</member>
<member name="M:DiffSharp.DtypeModule.|FloatingPoint|_|(DiffSharp.Dtype)">
<summary>
 Matches all floating point tensor element types
</summary>
</member>
<member name="T:DiffSharp.DtypeModule">
<summary>
 Contains functions and settings related to tensor element types
</summary>
</member>
<member name="M:DiffSharp.DtypeAutoOpens.opNotSupported2``1(System.String,DiffSharp.Dtype,DiffSharp.Dtype)">
<summary>
 Raise an exception indicating the given binary operation is not supported for the two given tensor element types.
</summary>
</member>
<member name="M:DiffSharp.DtypeAutoOpens.opNotSupportedOnDeviceType``1(System.String,DiffSharp.Dtype,DiffSharp.DeviceType)">
<summary>
 Raise an exception indicating the given operation is not supported for the given tensor device type.
</summary>
</member>
<member name="M:DiffSharp.DtypeAutoOpens.opNotSupported``1(System.String,DiffSharp.Dtype)">
<summary>
 Raise an exception indicating the given operation is not supported for the given tensor element type.
</summary>
</member>
<member name="M:DiffSharp.DtypeAutoOpens.Dtype.get_IsIntegral(DiffSharp.Dtype)">
<summary>
 Matches all integral tensor element types
</summary>
</member>
<member name="M:DiffSharp.DtypeAutoOpens.Dtype.get_IsFloatingPoint(DiffSharp.Dtype)">
<summary>
 Matches all floating point tensor element types
</summary>
</member>
<member name="T:DiffSharp.DtypeAutoOpens">
<summary>
 Contains global functions and settings related to tensor element types, used when writing backends.
</summary>
</member>
<member name="P:DiffSharp.PrinterModule.Default">
<summary>
 Get or set the default printer used when printing tensors. Note, use &lt;c&gt;dsharp.config(...)&lt;/c&gt; instead.
</summary>
</member>
<member name="T:DiffSharp.PrinterModule">
<summary>
 Contains functions and settings related to print options.
</summary>
</member>
<member name="M:DiffSharp.ShapeAutoOpens.flatIndexToIndex(System.Int32[],System.Int32)">
<summary>
 Converts the given flat index to an index in the context of the given shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeAutoOpens.indexToFlatIndex(System.Int32[],System.Int32[])">
<summary>
 Converts the given index to a flat index in the context of the given shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeAutoOpens.dilatedCoordinates(System.Int32[],System.Int32[])">
<summary>
 Dilates the given coordinates.
</summary>
</member>
<member name="M:DiffSharp.ShapeAutoOpens.mirrorCoordinates(System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Mirrors the coordinates in the given dimensions in the context of the given shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeAutoOpens.boundsToShape(System.Int32[0:])">
<summary>
 Converts the array of three-position bounds specifications to a shape without squeezing out scalars
</summary>
</member>
<member name="M:DiffSharp.ShapeAutoOpens.boundsToLocation(System.Int32[0:])">
<summary>
 Converts the array of three-position bounds specifications to a location.
</summary>
</member>
<member name="M:DiffSharp.ShapeAutoOpens.boundsIsScalar(System.Int32[0:])">
<summary>
 Checks if the full bounds is a scalar location
</summary>
</member>
<member name="M:DiffSharp.ShapeAutoOpens.shapeLength(System.Int32[])">
<summary>
 Gets the total number of elements in a shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.completeExpand(System.Int32[],System.Int32[])">
<summary>
 Completes the new shape for an expand operation based on the current shape of the tensor.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.completeDimUnsqueeze(System.Int32,System.Int32)">
<summary>
 Completes the given shape dimension with respect to a concrete dimension, for the unsqueeze operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.completeDim(System.Int32,System.Int32)">
<summary>
 Completes the given shape dimension with respect to a concrete dimension.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.complete(System.Int32,System.Int32[])">
<summary>
 Completes the given shape with respect to a tensor with the given number of elements.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.undilatedShape(System.Int32[],System.Int32[])">
<summary>
 Computes the shape that results from an undilation operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.broadcastShapes(System.Int32[][])">
<summary>
 Finds the shape into which all the shapes can be expanded.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.broadcast2(System.Int32[],System.Int32[])">
<summary>
 Finds the shape into which `shape1` and `shape2` can be expanded.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.flatten(System.Int32,System.Int32,System.Int32[])">
<summary>
 Computes the shape that results from a flatten operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.locationToBounds(System.Int32[],System.Int32[])">
<summary>
 Converts the given location to a three-element bounds array in the context of the given shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.unsqueezeAs(System.Int32[],System.Int32[])">
<summary>
 Computes the shape that results from an unsqueezeAs operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanUnsqueeze(System.Int32,System.Int32[])">
<summary>
 Checks if the given shape is appropriate for an unsqueeze operation and returns the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.squeeze(System.Int32,System.Int32[])">
<summary>
 Computes the shape that results from a squeeze operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanDropout3d(System.Int32[],System.Double)">
<summary>
 Checks if the given shape is appropriate for a dropout3d operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanDropout2d(System.Int32[],System.Double)">
<summary>
 Checks if the given shape is appropriate for a dropout2d operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanDropout(System.Double)">
<summary>
 Checks if the given shape is appropriate for a dropout operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanPad(System.Int32[],System.Int32[])">
<summary>
 Checks if the given shape is appropriate for a pad operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanDot(System.Int32[],System.Int32[])">
<summary>
 Checks if the given shape is appropriate for a dot product operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanBMM(System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a batched matrix multiplication operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanMatmul(System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a matmul operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanAddSlice(System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Checks if the given shape is appropriate for an addSlice operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanFlatten(System.Int32[],System.Int32,System.Int32)">
<summary>
 Checks if the given shape is appropriate for a flatten operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanView(System.Int32[],System.Int32[])">
<summary>
 Checks if the given shape is appropriate for a view operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanScatter(System.Int32[],System.Int32,System.Int32[],DiffSharp.Dtype,System.Int32[])">
<summary>
 Checks if the given shape is appropriate for a scatter operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanGather(System.Int32[],System.Int32,System.Int32[],DiffSharp.Dtype)">
<summary>
 Checks if the given shape is appropriate for a gather operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanDilate(System.Int32,System.Int32[])">
<summary>
 Checks if the given shape is appropriate for a dilate operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanRepeat(System.Int32[],System.Int32)">
<summary>
 Checks if the given shape is appropriate for a repeat operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanFlip(System.Int32,System.Int32[])">
<summary>
 Checks if the given shape is appropriate for a flip operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanPermute(System.Int32[],System.Int32[])">
<summary>
 Checks if the given shape is appropriate for a permute operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanSolve(System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a linear solve operation, and returns the resulting shape of the solution
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanDet(System.Int32[])">
<summary>
 Checks if the given shape is appropriate for a determinant operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanInvert(System.Int32[])">
<summary>
 Checks if the given shape is appropriate for a transpose operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanTranspose2d(System.Int32)">
<summary>
 Checks if the given shape is appropriate for a transpose operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanTranspose(System.Int32[],System.Int32,System.Int32)">
<summary>
 Checks if the given shape is appropriate for a transpose operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanExpand(System.Int32[],System.Int32[])">
<summary>
 Checks if one shape can expand into another through the addition of broadcast dimensions.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.canExpand(System.Int32[],System.Int32[])">
<summary>
 Indicates if one shape can expand into another through the addition of broadcast dimensions.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanMaxunpool3d(DiffSharp.Dtype,System.Int32[],DiffSharp.Dtype,System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a maxunpool operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanMaxunpool2d(DiffSharp.Dtype,System.Int32[],DiffSharp.Dtype,System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a maxunpool operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanMaxunpool1d(DiffSharp.Dtype,System.Int32[],DiffSharp.Dtype,System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a maxunpool operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanAvgpool3d(DiffSharp.Dtype,System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for an avgpool operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanMaxpool3d(DiffSharp.Dtype,System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a maxpool operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanMaxOrAvgpool3d(System.String,DiffSharp.Dtype,System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a maxpool operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanAvgpool2d(DiffSharp.Dtype,System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for an avgpool operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanMaxpool2d(DiffSharp.Dtype,System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a maxpool operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanMaxOrAvgpool2d(System.String,DiffSharp.Dtype,System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a maxpool operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanAvgpool1d(DiffSharp.Dtype,System.Int32[],System.Int32,System.Int32,System.Int32)">
<summary>
 Checks if the given shapes are appropriate for an avgpool operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanMaxpool1d(DiffSharp.Dtype,System.Int32[],System.Int32,System.Int32,System.Int32)">
<summary>
 Checks if the given shapes are appropriate for a maxpool operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanMaxOrAvgpool1d(System.String,DiffSharp.Dtype,System.Int32[],System.Int32,System.Int32,System.Int32)">
<summary>
 Checks if the given shapes are appropriate for a maxpool operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanConvTranspose3d(DiffSharp.DeviceType,DiffSharp.DeviceType,DiffSharp.Dtype,DiffSharp.Dtype,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a transposed convolution operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanConvTranspose2d(DiffSharp.DeviceType,DiffSharp.DeviceType,DiffSharp.Dtype,DiffSharp.Dtype,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a transposed convolution operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanConvTranspose1d(DiffSharp.DeviceType,DiffSharp.DeviceType,DiffSharp.Dtype,DiffSharp.Dtype,System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Checks if the given shapes are appropriate for a transposed convolution operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanConv3d(DiffSharp.DeviceType,DiffSharp.DeviceType,DiffSharp.Dtype,DiffSharp.Dtype,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a convolution operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanConv2d(DiffSharp.DeviceType,DiffSharp.DeviceType,DiffSharp.Dtype,DiffSharp.Dtype,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a convolution operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanConv1d(DiffSharp.DeviceType,DiffSharp.DeviceType,DiffSharp.Dtype,DiffSharp.Dtype,System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
<summary>
 Checks if the given shapes are appropriate for a convolution operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkConvDType(System.String,DiffSharp.Dtype)">
<summary>
 Check if the tensor element type is appropriate for a convolution operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkDtypes(DiffSharp.Dtype,DiffSharp.Dtype)">
<summary>
 Checks if the two tensor element types are equal.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkDeviceTypes(DiffSharp.DeviceType,DiffSharp.DeviceType)">
<summary>
 Checks if the two device types are equal.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.computeTranspose2d(System.Int32[])">
<summary>
 Checks if the given shapes are appropriate for a transpose operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanUnstack(System.Int32[],System.Int32)">
<summary>
 Checks if the given shapes are appropriate for an unstack operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanSplit(System.Int32[],System.Int32[],System.Int32)">
<summary>
 Checks if the given shapes are appropriate for a split operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanCat(System.Int32[][],System.Int32)">
<summary>
 Checks if the given shapes are appropriate for a concatenation operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.dilated(System.Int32[],System.Int32[])">
<summary>
 Computes the shape that results from a dilation operation.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanIndex(System.Int32[],System.Int32[])">
<summary>
 Checks if the given index is valid in the context of the given shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanGetSlice(System.Int32[],System.Int32[0:])">
<summary>
 Checks if the given shapes are appropriate for a GetSlice operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.checkCanStack(System.Int32[][],System.Int32)">
<summary>
 Checks if the given shapes are appropriate for a stack operation and returns information related to the resulting shape.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.contains(System.Int32[],System.Int32[])">
<summary>
 Indicates if one shape contains another.
</summary>
</member>
<member name="P:DiffSharp.ShapeModule.scalar">
<summary>
 The shape for a scalar value.
</summary>
</member>
<member name="M:DiffSharp.ShapeModule.nelement(System.Int32[])">
<summary>
 Gets the total number of elements in the shape.
</summary>
</member>
<member name="T:DiffSharp.ShapeModule">
<summary>
 Contains functions and values related to tensor shapes.
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Uniform(System.Double,System.Double)">
<summary>
 Samples a random value from the uniform distribution with the given parameters [low, high).
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Uniform">
<summary>
 Samples a random value from the standard uniform distribution over the interval [0,1).
</summary>
</member>
<member name="M:DiffSharp.Util.Random.UUID">
<summary>
 Returns a universally unique identifier (UUID) string
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Shuffle``1(``0[])">
<summary>
 Returns an array that is a randomly-shuffled version of the given array, using the Durstenfeld/Knuth shuffle.
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Seed(System.Int32)">
<summary>
 Sets the random seed.
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Normal(System.Double,System.Double)">
<summary>
 Samples a random value from the normal distribution with the given mean and standard deviation.
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Normal">
<summary>
 Samples a random value from the standard normal distribution with mean 0 and standard deviation 1.
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Multinomial(System.Double[0:],System.Int32)">
<summary>
 Returns a 2D array where each row contains `numSamples` indices sampled from the multinomial probability distribution defined by the probabilities in the corresponding row of the `probs` array.
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Multinomial(System.Double[],System.Int32)">
<summary>
 Samples a number of random values  array of random values for the given weighted distribution
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Integer(System.Int32,System.Int32)">
<summary>
 Samples a random integer in the given range [low, high).
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Integer">
<summary>
 Samples a non-negative random integer
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Double(System.Double,System.Double)">
<summary>
 Samples a double value in the given range [low, high)
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Double">
<summary>
 Samples a double value in the range [0, 1)
</summary>
</member>
<member name="M:DiffSharp.Util.Random.ChoiceIndex(System.Double[])">
<summary>
 Samples an index at random with the given categorical probabilities.
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Choice``1(``0[],System.Double[])">
<summary>
 Samples a value at random from the given array using the given categorical probabilities.
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Choice``1(``0[])">
<summary>
 Samples a value at random from the given array.
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Bernoulli">
<summary>
 Samples a random value from the Bernoulli distribution.
</summary>
</member>
<member name="M:DiffSharp.Util.Random.Bernoulli(System.Double)">
<summary>
 Samples a random value from the Bernoulli distribution with the given probability.
</summary>
</member>
<member name="T:DiffSharp.Util.Random">
<summary>
 Contains operations relating to pseudo-random number generation.
</summary>
</member>
<member name="T:DiffSharp.Util.GlobalNestingLevel">
<summary>
 Contains operations to get, set or reset the global nesting level for differentiation operations.
</summary>
</member>
<member name="T:DiffSharp.Util.NestingLevel">
<summary>
 Represents a differentiation nesting level.
</summary>
</member>
<member name="M:DiffSharp.Util.ExtensionAutoOpens.print``1(``0)">
<summary>
 Print the given value to the console using the &apos;%A&apos; printf format specifier
</summary>
</member>
<member name="M:DiffSharp.Util.ExtensionAutoOpens.array4D``4(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a non-jagged 4D array from jagged data.
</summary>
</member>
<member name="M:DiffSharp.Util.ExtensionAutoOpens.array3D``3(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a non-jagged 3D array from jagged data.
</summary>
</member>
<member name="M:DiffSharp.Util.ExtensionAutoOpens.notNull``1(``0)">
<summary>
 Indicates if a value is not null.
</summary>
</member>
<member name="T:DiffSharp.Util.ExtensionAutoOpens">
<summary>
 Contains auto-opened extensions to the F# programming model.
</summary>
</member>
<member name="M:DiffSharp.Util.Dictionary.copyValues``2(System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Gets a fresh array containing the values of the dictionary.
</summary>
</member>
<member name="M:DiffSharp.Util.Dictionary.copyKeys``2(System.Collections.Generic.Dictionary{``0,``1})">
<summary>
 Gets a fresh array containing the keys of the dictionary.
</summary>
</member>
<member name="T:DiffSharp.Util.Dictionary">
<summary>
 Contains extensions related to .NET Dictionary. 
</summary>
</member>
<member name="M:DiffSharp.Util.OrderedDictionary.copyKeys``1(System.Collections.Specialized.OrderedDictionary)">
<summary>
 Gets a fresh array containing the keys of the dictionary.
</summary>
</member>
<member name="T:DiffSharp.Util.OrderedDictionary">
<summary>
 Contains extensions related to .NET OrderedDictionary. 
</summary>
</member>
<member name="M:DiffSharp.Util.Seq.toArrayQuick``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Like Seq.toArray but does not clone the array if the input is already an array
</summary>
</member>
<member name="M:DiffSharp.Util.Seq.hasDuplicates``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Indicates if a sequence has duplicate elements.
</summary>
</member>
<member name="M:DiffSharp.Util.Seq.duplicates``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Gets the duplicate elements in the sequence.
</summary>
</member>
<member name="M:DiffSharp.Util.Seq.allEqual``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Indicates if all elements of the sequence are equal.
</summary>
</member>
<member name="M:DiffSharp.Util.Seq.minIndex``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Gets the index of the minimum element of the sequence.
</summary>
</member>
<member name="M:DiffSharp.Util.Seq.maxIndex``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Gets the index of the maximum element of the sequence.
</summary>
</member>
<member name="T:DiffSharp.Util.Seq">
<summary>
 Contains extensions to the F# Seq module. 
</summary>
</member>
<member name="M:DiffSharp.Util.ArrayND.zeroCreate(System.Int32[])">
<summary>
 Initializes an array with a given shape and initializer function.
</summary>
</member>
<member name="M:DiffSharp.Util.ArrayND.init``1(System.Int32[],Microsoft.FSharp.Core.FSharpFunc{System.Int32[],``0})">
<summary>
 Initializes an array with a given shape and initializer function.
</summary>
</member>
<member name="M:DiffSharp.Util.Array5D.zeroCreate``1(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary></summary> <exclude />
</member>
<member name="M:DiffSharp.Util.Array4D.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[0:, 0:, 0:])">
<summary>
 Builds a new array whose elements are the results of applying the given function to each of the elements of the array.
</summary>
</member>
<member name="M:DiffSharp.Util.Array.getUniqueCounts``1(System.Boolean,``0[])">
<summary>
 Gets the unique counts of the input array.
</summary>
</member>
<member name="M:DiffSharp.Util.Array.cumulativeSum``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0[])">
<summary>
 Gets the cumulative sum of the input array.
</summary>
</member>
<member name="M:DiffSharp.Util.Array.allClose``3(Microsoft.FSharp.Core.FSharpFunc{``0,``0},Microsoft.FSharp.Core.FSharpFunc{``1,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0,``0,``0[],``0[])">
<summary>
 Determines if all values of the first array lie within the given tolerances of the second array.
</summary>
</member>
<member name="T:DiffSharp.Util.Array">
 <summary>
   Contains extensions to the F# Array module. 
 </summary>

 <namespacedoc>
   <summary>Contains utilities and library extensions related to the DiffSharp programming model.</summary>
 </namespacedoc>
</member>
<member name="M:DiffSharp.Util.UtilAutoOpens.bytesReadable(System.Int64)">
<summary>
 Return a human-readable string representation of the given value in Bytes.
</summary>
</member>
<member name="M:DiffSharp.Util.UtilAutoOpens.pngToHtml(System.String,System.Int32)">
<summary>
 Given a PNG image file name, returns an HTML image element with the image content included as a Base64 encoded string
</summary>
</member>
<member name="M:DiffSharp.Util.UtilAutoOpens.fileToBase64String(System.String)">
<summary>
 Returns the file contents as Base64 encoded string
</summary>
</member>
<member name="M:DiffSharp.Util.UtilAutoOpens.thousandsFloat(System.Double)">
<summary>
 Formats an integer as a string with comma as thousands separator
</summary>
</member>
<member name="M:DiffSharp.Util.UtilAutoOpens.thousandsInt(System.Int32)">
<summary>
 Formats an integer as a string with comma as thousands separator
</summary>
</member>
<member name="M:DiffSharp.Util.UtilAutoOpens.stringPadAs(System.String,System.String)">
<summary>
 Left-pads a string to match the length of another string.
</summary>
</member>
<member name="M:DiffSharp.Util.UtilAutoOpens.stringPad(System.String,System.Int32)">
<summary>
 Left-pads a string up to the given length.
</summary>
</member>
<member name="M:DiffSharp.Util.UtilAutoOpens.indentNewLines(System.String,System.Int32)">
<summary>
 Indents all lines of the given string by the given number of spaces.
</summary>
</member>
<member name="P:DiffSharp.Util.UtilAutoOpens.log10Val">
<summary>
 Value of log(10).
</summary>
</member>
<member name="P:DiffSharp.Util.UtilAutoOpens.logSqrt2Pi">
<summary>
 Value of log(sqrt(2*Math.PI)).
</summary>
</member>
<member name="M:DiffSharp.Util.UtilAutoOpens.loadBinary``1(System.String)">
<summary>
 Loads the given value from the given local file using binary serialization.
</summary>
</member>
<member name="M:DiffSharp.Util.UtilAutoOpens.saveBinary``1(``0,System.String)">
<summary>
 Saves the given value to the given local file using binary serialization.
</summary>
</member>
<member name="M:DiffSharp.Util.UtilAutoOpens.memoize``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Returns a function that memoizes the given function using a lookaside table.
</summary>
</member>
<member name="T:DiffSharp.Util.UtilAutoOpens">
<summary>
 Contains auto-opened utilities related to the DiffSharp programming model.
</summary>
</member>
<member name="M:DiffSharp.Util.DataConverter.|SeqTy|_|(System.Type)">
<summary>
 Matches a 1D sequence type (seq&lt;_&gt;) or a subclass.
</summary>
</member>
<member name="M:DiffSharp.Util.DataConverter.|TupleTy|_|(System.Type)">
<summary>
 Matches a tuple type.
</summary>
</member>
<member name="M:DiffSharp.Util.DataConverter.|ArrayTy|_|(System.Type)">
<summary>
 Matches an array type of arbitrary rank.
</summary>
</member>
<member name="M:DiffSharp.Util.DataConverter.seqElements(System.Object)">
<summary>
 Gets the elements of an arbitrary IEnumerble.
</summary>
</member>
<member name="T:DiffSharp.Util.DataConverter">
<summary>
 Contains operations relating to converting .NET data to tensor data.
</summary>
</member>
<member name="M:DiffSharp.Util.RandomModule.shuffledIndices(System.Int32)">
<summary>
 Returns a function that maps a given index to a shuffled version of the indexes up to the given `length`
</summary>
</member>
<member name="T:DiffSharp.Util.RandomModule">
<summary>
 Contains operations relating to pseudo-random number generation.
</summary>
</member>
<member name="P:DiffSharp.Backends.RawTensor.Shape">
<summary>
 Gets the shape of the tensor
</summary>
</member>
<member name="P:DiffSharp.Backends.RawTensor.Nelement">
<summary>
 Gets the number of elements in the tensor
</summary>
</member>
<member name="P:DiffSharp.Backends.RawTensor.Handle">
<summary>
 Gets a handle to the underlying representation of the the tensor. For example, if the Torch
 backend is used this will be the corresponding TorchSharp TorchTensor.
</summary>
</member>
<member name="P:DiffSharp.Backends.RawTensor.Dtype">
<summary>
 Gets the element storage type for the tensor
</summary>
</member>
<member name="P:DiffSharp.Backends.RawTensor.Dim">
<summary>
 Gets the dimensionality of the tensor
</summary>
</member>
<member name="P:DiffSharp.Backends.RawTensor.DeviceType">
<summary>
 Gets the device type for the tensor
</summary>
</member>
<member name="P:DiffSharp.Backends.RawTensor.Device">
<summary>
 Gets the device for the tensor
</summary>
</member>
<member name="P:DiffSharp.Backends.RawTensor.Backend">
<summary>
 Gets the backend for the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ZerosLike(System.Int32[],Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor filled with zero values for the given shape and configuration settings,
 defaulting to the configuration settings of the object tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ZerosInPlace">
<summary>
 Modifies the tensor by setting all values to zero
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Zeros(System.Int32[],Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets the zero tensor for the given shape and configuration
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ZeroLike(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a zero tensor for the given configuration settings, defaulting to the configuration settings of the object tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Zero(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets the scalar zero tensor for the given configuration
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ViewT(System.Int32[])">
<summary>
 Returns the tensor with the same values viewed as a different shape
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.UnstackT(System.Int32)">
<summary>
 Unstack the given tensors along the given dimension
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.UnsqueezeT(System.Int32)">
<summary>
 Returns the tensor with the same values and a dimension of size 1 inserted before the given dimension.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.UndilateT(System.Int32[])">
<summary>
 Returns the reverse of the dilation of the tensor using the given dilations parameters
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.TransposeT2">
<summary>
 Returns the transpose of a 2D tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.TransposeT(System.Int32,System.Int32)">
<summary>
 Returns the transpose of the tensor between the given dimensions
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ToValues">
 <summary>Get a .NET object for all the values in the tensor.</summary>

 <remarks>The runtime type of the returned object is either a .NET scalar
 or array corresponding to the shape and element type of the tensor.</remarks>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ToScalar">
<summary>
 Returns a .NET object for the value of a scalar tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ToScalar">
<summary>
 Gets a .NET object representing the value of a scalar tensor 
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ToArray">
<summary>
 Returns a .NET array object for the values of a non-scalar tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.TanhT">
<summary>
 Returns the element-wise tanh of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.TanhInPlace">
<summary>
 Modifies the tensor by the element-wise tanh of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.TanT">
<summary>
 Returns the element-wise tangent of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.TanInPlace">
<summary>
 Modifies the tensor by the element-wise tangent of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SumTDim(System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype})">
<summary>
 Returns the tensor representing the summation of the tensor along the given dimension
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SumT(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype})">
<summary>
 Returns the scalar tensor for the summation of all elements in the tensor 
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SubTT0(System.IConvertible)">
<summary>
 Returns the element-wise subtraction of the tensor and a scalar, where the scalar is logically
 broadcast to the same shape as the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SubTT(DiffSharp.Backends.RawTensor)">
<summary>
 Returns the element-wise subtraction of two tensors
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SubScalarInPlace(System.IConvertible)">
<summary>
 Modifies the tensor by the element-wise subtraction of the tensor and a scalar, where the scalar is logically
 broadcast to the same shape as the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SubInPlace(DiffSharp.Backends.RawTensor)">
<summary>
 Modifies the tensor by the element-wise subtraction of two tensors
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SubFromT0T(System.IConvertible)">
<summary>
 Returns the element-wise subtraction of the scalar and a tensor, where the scalar is logically
 broadcast to the same shape as the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.StackTs(DiffSharp.Backends.RawTensor[],System.Int32)">
<summary>
 Stack the given tensors along the given dimension
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SqueezeT(System.Int32)">
<summary>
 Returns the tensor with the same values and the given dimension removed. The given dimension must be of size 1.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SqrtT">
<summary>
 Returns the element-wise square root of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SqrtInPlace">
<summary>
 Modifies the tensor by the element-wise square root of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SplitT(System.Int32[],System.Int32)">
<summary>
 Split the given tensors along the given dimensions
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SolveTT(DiffSharp.Backends.RawTensor)">
<summary>
 Returns the solution of single a square system of linear equations with a unique solution or a batch of several such systems
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SoftplusT">
<summary>
 Returns the element-wise softplus of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SoftplusInPlace">
<summary>
 Modifies the tensor by the element-wise softplus of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SinhT">
<summary>
 Returns the element-wise sinh of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SinhInPlace">
<summary>
 Modifies the tensor by the element-wise sinh of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SinT">
<summary>
 Returns the element-wise sine of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SinInPlace">
<summary>
 Modifies the tensor by the element-wise sine of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SignT">
<summary>
 Returns the element-wise sign of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SignInPlace">
<summary>
 Modifies the tensor by the element-wise sign of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SigmoidT">
<summary>
 Returns the element-wise sigmoid of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SigmoidInPlace">
<summary>
 Modifies the tensor by the element-wise sigmoid of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.SetMutable">
<summary>
 A backdoor to switch this tensor to be usable as a mutable tensor. You should have a unique handle to
 this tensor for the entire time it is being used as a mutable tensor.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ScatterT(System.Int32,DiffSharp.Backends.RawTensor,System.Int32[])">
<summary>
 Returns a tensor with given destination shape where values are copied from the current tensor to locations specified by the dimension and indices.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.RoundT">
<summary>
 Returns the element-wise rounding of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.RoundInPlace">
<summary>
 Modifies the tensor by the element-wise rounding of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ReluT">
<summary>
 Returns the element-wise ReLU of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ReluInPlace">
<summary>
 Modifies the tensor by the element-wise ReLU of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.RandomNormalLike(System.Int32[],Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor filled with random values from a normal distribution for the given shape and configuration settings,
 defaulting to the configuration settings of the object tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.RandomNormalInPlace">
<summary>
 Modifies the tensor by setting all values taken from a normal distribution with mean 0 and variance 1.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.RandomNormal(System.Int32[],Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor filled with random values from the normal distribution for the given shape and configuration
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.RandomLike(System.Int32[],Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor filled with random values for the given shape and configuration settings,
 defaulting to the configuration settings of the object tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.RandomIntLike(System.Int32[],System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor filled with random integer values from the given range for the given shape and configuration settings,
 defaulting to the configuration settings of the object tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.RandomIntInPlace(System.Int32,System.Int32)">
<summary>
 Gets a tensor filled with random integers from the given range 
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.RandomInt(System.Int32[],System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor filled with random integer values from the given range for the given shape and configuration
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.RandomInPlace">
<summary>
 Modifies the tensor by setting it to random values taken from a uniform distribution in [0, 1).
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Random(System.Int32[],Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor filled with random values for the given shape and configuration
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.PowTT0(System.IConvertible)">
<summary>
 Returns the element-wise exponentiation of a tensor and a scalar, where the scalar is logically
 broadcast to the same shape as the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.PowTT(DiffSharp.Backends.RawTensor)">
<summary>
 Returns the element-wise exponentiation of two tensors
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.PowScalarInPlace(System.IConvertible)">
<summary>
 Modifies the tensor by the element-wise exponentiation of a tensor and a scalar, where the scalar is logically
 broadcast to the same shape as the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.PowInPlace(DiffSharp.Backends.RawTensor)">
<summary>
 Modifies the tensor by the element-wise exponentiation of two tensors
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.PowFromT0T(System.IConvertible)">
<summary>
 Returns the element-wise exponentiation of a scalar and a tensor, where the scalar is logically
 broadcast to the same shape as the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.PermuteT(System.Int32[])">
<summary>
 Returns a view of the original tensor with its dimensions permuted
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.OnesLike(System.Int32[],Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor filled with one values for the given shape and configuration settings,
 defaulting to the configuration settings of the object tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.OnesInPlace">
<summary>
 Modifies the tensor by setting all values to one
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Ones(System.Int32[],Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor filled with 1 values for the given shape and configuration
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.OneLike(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a scalar one tensor for the given configuration settings, defaulting to the configuration settings of the object tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.One(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets the scalar 1 tensor for the given configuration
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.NeqTT(DiffSharp.Backends.RawTensor)">
<summary>
 Returns a boolean tensor comparing each element pairwise with the corresponding element in &lt;c&gt;t2&lt;/c&gt;
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.NeqInPlace(DiffSharp.Backends.RawTensor)">
<summary>
 Modifies the tensor by comparing each element pairwise with the corresponding element in &lt;c&gt;t2&lt;/c&gt;
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.NegT">
<summary>
 Returns the element-wise negation of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.NegInPlace">
<summary>
 Modifies the tensor by the element-wise negation of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MulTT0(System.IConvertible)">
<summary>
 Returns the element-wise multiplication of a tensor and a scalar, where the scalar is logically
 broadcast to the same shape as the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MulTT(DiffSharp.Backends.RawTensor)">
<summary>
 Returns the element-wise multiplication of two tensors
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MulScalarInPlace(System.IConvertible)">
<summary>
 Modifies the tensor by the element-wise multiplication of a tensor and a scalar, where the scalar is logically
 broadcast to the same shape as the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MulInPlace(DiffSharp.Backends.RawTensor)">
<summary>
 Modifies the tensor by the element-wise multiplication of two tensors
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MoveTo(DiffSharp.Device)">
<summary>
 Returns a tensor moved to the given device.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MinReduceT(System.Int32,System.Boolean)">
<summary>
 Gets a tensor containing values and indexes of a minimum value of the tensor reducing along the given dimension
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MinIndexT">
<summary>
 Gets the index of a minimum value of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MaxUnpool3D(DiffSharp.Backends.RawTensor,System.Int32[])">
<summary>
 Returns the 3D maxunpool of a tensor using the given indices for locations of maximums
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MaxUnpool2D(DiffSharp.Backends.RawTensor,System.Int32[])">
<summary>
 Returns the 2D maxunpool of a tensor using the given indices for locations of maximums
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MaxUnpool1D(DiffSharp.Backends.RawTensor,System.Int32[])">
<summary>
 Returns the 1D maxunpool of a tensor using the given indices for locations of maximums
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MaxReduceT(System.Int32,System.Boolean)">
<summary>
 Gets a tensor containing values and indexes of a maximum value of the tensor reducing along the given dimension
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MaxPool3D(System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Returns the 3D maxpool of a tensor and its chosen maximum indices
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MaxPool2D(System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Returns the 2D maxpool of a tensor and its chosen maximum indices
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MaxPool1D(System.Int32,System.Int32,System.Int32)">
<summary>
 Returns the 1D maxpool of a tensor and its chosen maximum indices
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MaxIndexT">
<summary>
 Gets the index of a maximum value of the tensor 
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MatMulTT(DiffSharp.Backends.RawTensor)">
<summary>
 Returns the matrix multiplication of two tensors
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.MatMulInPlace(DiffSharp.Backends.RawTensor)">
<summary>
 Modifies the tensor by the matrix multiplication of two tensors
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.LtTT(DiffSharp.Backends.RawTensor)">
<summary>
 Returns a boolean tensor comparing each element pairwise with the corresponding element in &lt;c&gt;t2&lt;/c&gt;
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.LtInPlace(DiffSharp.Backends.RawTensor)">
<summary>
 Modifies the tensor by comparing each element pairwise with the corresponding element in &lt;c&gt;t2&lt;/c&gt;
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.LogT">
<summary>
 Returns the element-wise natural logarithm of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.LogInPlace">
<summary>
 Modifies the tensor by the element-wise natural logarithm of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Log10T">
<summary>
 Returns the element-wise base10 logarithm of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Log10InPlace">
<summary>
 Modifies the tensor by the element-wise base10 logarithm of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.LeTT(DiffSharp.Backends.RawTensor)">
<summary>
 Returns a boolean tensor comparing each element pairwise with the corresponding element in &lt;c&gt;t2&lt;/c&gt;
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.LeInPlace(DiffSharp.Backends.RawTensor)">
<summary>
 Modifies the tensor by comparing each element pairwise with the corresponding element in &lt;c&gt;t2&lt;/c&gt;
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.IsNaNT">
<summary>
 Returns a boolean tensor where each element indicates if the corresponding element in the tensor is a NaN value
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.IsInfT">
<summary>
 Returns a boolean tensor where each element indicates if the corresponding element in the tensor is an infinity value
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.InverseT">
<summary>
 Returns the inverse of a single square matrix (2d tensor) or a batch of square matrices (3d tensor)
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.GtTT(DiffSharp.Backends.RawTensor)">
<summary>
 Returns a boolean tensor comparing each element pairwise with the corresponding element in &lt;c&gt;t2&lt;/c&gt;
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.GtInPlace(DiffSharp.Backends.RawTensor)">
<summary>
 Modifies the tensor by comparing each element pairwise with the corresponding element in &lt;c&gt;t2&lt;/c&gt;
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.GetSlice(System.Int32[0:])">
 <summary> Get a slice of the given tensor.</summary>

 <param name="fullBounds">
  The indexes are an Nx3 array.  The first row is the start bounds, the second row is
  the end bounds, the third is 1/0 indicating dimension removal.
 </param>
</member>
<member name="M:DiffSharp.Backends.RawTensor.GetItem(System.Int32[])">
<summary>
 Gets a .NET object representing the value of the tensor at the given indexes
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.GeTT(DiffSharp.Backends.RawTensor)">
<summary>
 Returns a boolean tensor comparing each element pairwise with the corresponding element in &lt;c&gt;t2&lt;/c&gt;
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.GeInPlace(DiffSharp.Backends.RawTensor)">
<summary>
 Modifies the tensor by comparing each element pairwise with the corresponding element in &lt;c&gt;t2&lt;/c&gt;
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.GatherT(System.Int32,DiffSharp.Backends.RawTensor)">
<summary>
 Returns a tensor selecting the given indices from the given dimension and stacking those in the order specified.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.FullLike(System.Int32[],System.IConvertible,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor filled with the given scalar value for the given shape and configuration settings,
 defaulting to the configuration settings of the object tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Full(System.Int32[],System.IConvertible,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor filled with the given value for the given shape and configuration
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.FloorT">
<summary>
 Returns the element-wise integer floor of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.FloorInPlace">
<summary>
 Modifies the tensor by the element-wise integer floor of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.FlipT(System.Int32[])">
<summary>
 Returns the flip of the tensor along the given dimensions 
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Expand(System.Int32[])">
<summary>
 Expand the shape of the tensor.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ExpT">
<summary>
 Returns the element-wise natural exponentiation of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ExpInPlace">
<summary>
 Modifies the tensor by the element-wise natural exponentiation of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Equals(DiffSharp.Backends.RawTensor)">
<summary>
 Compare two tensors for equality
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.EqTT(DiffSharp.Backends.RawTensor)">
<summary>
 Returns a boolean tensor comparing each element pairwise with the corresponding element in &lt;c&gt;t2&lt;/c&gt;
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.EqInPlace(DiffSharp.Backends.RawTensor)">
<summary>
 Modifies the tensor by comparing each element pairwise with the corresponding element in &lt;c&gt;t2&lt;/c&gt;
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.EmptyLike(System.Int32[],Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor filled with arbitrary values for the given shape and configuration settings,
 defaulting to the configuration settings of the object tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Empty(System.Int32[],Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor containing arbitrary values for the given shape and configuration
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.DivTT0(System.IConvertible)">
<summary>
 Returns the element-wise division of a tensor by a scalar, where the scalar is logically
 broadcast to the same shape as the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.DivTT(DiffSharp.Backends.RawTensor)">
<summary>
 Returns the element-wise division of two tensors
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.DivScalarInPlace(System.IConvertible)">
<summary>
 Modifies the tensor by the element-wise division of a tensor by a scalar, where the scalar is logically
 broadcast to the same shape as the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.DivInPlace(DiffSharp.Backends.RawTensor)">
<summary>
 Modifies the tensor by the element-wise division of two tensors
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.DivFromT0T(System.IConvertible)">
<summary>
 Returns the element-wise division of a scalar by a tensor, where the scalar is logically
 broadcast to the same shape as the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.DilateT(System.Int32[])">
<summary>
 Returns the dilation of the tensor using the given dilations parameters
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.DetT">
<summary>
 Returns the determinant of a square matrix
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.CreateLike(System.Object,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Gets a tensor filled with values drawn from the given .NET object for the
 given configuration settings, defaulting to the configuration settings of the object tensor.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Create(System.Object,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>
   Gets a tensor filled with values drawn from the given .NET object.
 </summary>

 <remarks>
  The value may be a scalar, an array, or an array of tupled objects. If the <c>dtype</c> is not specified
  then it is inferred from the .NET type of the object.
 </remarks>
</member>
<member name="M:DiffSharp.Backends.RawTensor.CoshT">
<summary>
 Returns the element-wise cosh of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.CoshInPlace">
<summary>
 Modifies the tensor by the element-wise cosh of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.CosT">
<summary>
 Returns the element-wise cosine of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.CosInPlace">
<summary>
 Modifies the tensor by the element-wise cosine of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Conv3D(DiffSharp.Backends.RawTensor,System.Int32[],System.Int32[])">
<summary>
 Returns the 3D convolution of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Conv2D(DiffSharp.Backends.RawTensor,System.Int32[],System.Int32[])">
<summary>
 Returns the 2D convolution of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Conv1D(DiffSharp.Backends.RawTensor,System.Int32,System.Int32)">
<summary>
 Returns the 1D convolution of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ComputeHash">
<summary>
 Returns a hash of the contents of the tensor. This operation may cause the
 tensor to be moved to the CPU, and its entire contents iterated.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Clone">
<summary>
 Clone the underlying storage of the tensor.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ClampT(DiffSharp.Backends.RawTensor,DiffSharp.Backends.RawTensor)">
<summary>
 Returns a tensor with values constrained by the corresponding elements in the low/high tensors.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.ClampInPlace(DiffSharp.Backends.RawTensor,DiffSharp.Backends.RawTensor)">
<summary>
 Modifies the tensor by with values constrained by the corresponding elements in the low/high tensors.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.CeilT">
<summary>
 Returns the element-wise integer ceiling of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.CeilInPlace">
<summary>
 Modifies the tensor by the element-wise integer ceiling of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.CatTs(DiffSharp.Backends.RawTensor[],System.Int32)">
<summary>
 Concatenate the given tensors along the given dimension
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.Cast(DiffSharp.Dtype)">
<summary>
 Returns a tensor where the elements have each been cast to the given tensor element storage type.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.BMMTT(DiffSharp.Backends.RawTensor)">
<summary>
 Returns the batched matrix multiplication of two tensors
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AvgPoolReverse3D(DiffSharp.Backends.RawTensor,System.Int32[],System.Int32[],System.Int32[])">
 <summary>Returns the reverse mode of a 3D avgpool of a tensor, apportioning each part of the adjoint equally to each corresponding input</summary>
 <remarks>The originalInput parameter is only used for shape information</remarks>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AvgPoolReverse2D(DiffSharp.Backends.RawTensor,System.Int32[],System.Int32[],System.Int32[])">
 <summary>Returns the reverse mode of a 2D avgpool of a tensor, apportioning each part of the adjoint equally to each corresponding input</summary>
 <remarks>The originalInput parameter is only used for shape information</remarks>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AvgPoolReverse1D(DiffSharp.Backends.RawTensor,System.Int32,System.Int32,System.Int32)">
 <summary>Returns the reverse mode of a 1D avgpool of a tensor, apportioning each part of the adjoint equally to each corresponding input</summary>
 <remarks>The originalInput parameter is only used for shape information</remarks>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AvgPool3D(System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Returns the 2D avgpool of a tensor 
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AvgPool2D(System.Int32[],System.Int32[],System.Int32[])">
<summary>
 Returns the 2D avgpool of a tensor 
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AvgPool1D(System.Int32,System.Int32,System.Int32)">
<summary>
 Returns the 1D avgpool of a tensor 
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AtanT">
<summary>
 Returns the element-wise atan of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AtanInPlace">
<summary>
 Modifies the tensor by the element-wise atan of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AsinT">
<summary>
 Returns the element-wise asin of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AsinInPlace">
<summary>
 Modifies the tensor by the element-wise asin of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AllClose(DiffSharp.Backends.RawTensor,System.Double,System.Double)">
<summary>
 Indicates if the two tensors have the same shape and element type, and all corresponding values
 are equal up to the given tolerances.
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AddTTSlice(System.Int32[],DiffSharp.Backends.RawTensor)">
<summary>
 Adds a slice of &lt;c&gt;t2&lt;/c&gt; at the given location to the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AddTT0(System.IConvertible,Microsoft.FSharp.Core.FSharpOption{System.IConvertible})">
<summary>
 Returns the element-wise addition of a tensor and a scalar
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AddTT(DiffSharp.Backends.RawTensor,Microsoft.FSharp.Core.FSharpOption{System.IConvertible})">
<summary>
 Returns the element-wise addition of the two tensors
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AddSliceInPlace(System.Int32[],DiffSharp.Backends.RawTensor)">
<summary>
 Adds a slice of &lt;c&gt;t2&lt;/c&gt; at the given location to the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AddScalarInPlace(System.IConvertible)">
<summary>
 Modifies the tensor by the element-wise addition of two scalars
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AddInPlace(DiffSharp.Backends.RawTensor,Microsoft.FSharp.Core.FSharpOption{System.IConvertible})">
<summary>
 Modifies the tensor by the element-wise addition of the two tensors
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AcosT">
<summary>
 Returns the element-wise cos of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AcosInPlace">
<summary>
 Modifies the tensor by the element-wise cos of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AbsT">
<summary>
 Returns the element-wise absolute value of the tensor
</summary>
</member>
<member name="M:DiffSharp.Backends.RawTensor.AbsInPlace">
<summary>
 Modifies the tensor by the element-wise absolute value of the tensor
</summary>
</member>
<member name="T:DiffSharp.Backends.RawTensor">
 <summary>
   Represents a raw (i.e. non-differentiable immutable) tensor implemented by a DiffSharp backend.
 </summary>

 <remarks>
  Each backend will provide one of more .NET implementations of this type, which may in turn
  wrap handles to native implementations.
 </remarks>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.Zeros(System.Int32[],DiffSharp.Dtype,DiffSharp.Device)">
<summary>
 Gets a tensor filled with zeros for the given shape and device
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.Zero(DiffSharp.Dtype,DiffSharp.Device)">
<summary>
 Gets the scalar 0 tensor for the given device
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.Seed(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Seed all backends with the given random seed, or a new seed based on the current time
 if no seed is specified.
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.Seed(System.Int32)">
<summary>
 Sets the seed for the default random number generator of the backend
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.RandomNormal(System.Int32[],DiffSharp.Dtype,DiffSharp.Device)">
<summary>
 Gets a tensor filled with random values from the normal distribution for the given shape and device
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.RandomInt(System.Int32[],System.Int32,System.Int32,DiffSharp.Dtype,DiffSharp.Device)">
<summary>
 Gets a tensor filled with random integers from the given range for the given shape and device
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.Random(System.Int32[],DiffSharp.Dtype,DiffSharp.Device)">
<summary>
 Gets a tensor filled with random values for the given shape and device
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.Ones(System.Int32[],DiffSharp.Dtype,DiffSharp.Device)">
<summary>
 Gets a tensor filled with ones for the given shape and device
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.One(DiffSharp.Dtype,DiffSharp.Device)">
<summary>
 Gets the scalar 1 tensor for the given device
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.IsDeviceTypeAvailable(DiffSharp.DeviceType)">
<summary>
 Indicates if a device type is supported by this backend
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.GetDevices(Microsoft.FSharp.Core.FSharpOption{DiffSharp.DeviceType})">
<summary>
 Gets the devices supported by this backend
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.Get(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
<summary>
 Get the backend implementation for the given tensor element type and backend.
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.Full(System.Int32[],System.IConvertible,DiffSharp.Dtype,DiffSharp.Device)">
<summary>
 Gets a tensor filled with the given value for the given shape and device
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.Empty(System.Int32[],DiffSharp.Dtype,DiffSharp.Device)">
<summary>
 Gets a tensor filled with arbitrary values for the given shape and device
</summary>
</member>
<member name="M:DiffSharp.Backends.BackendTensorStatics.CreateFromFlatArray(System.Array,System.Int32[],DiffSharp.Dtype,DiffSharp.Device)">
<summary>
 Create a tensor of appropriate dtype from a scalar or array of appropriate values.
 A backend type is delivered consistent with in-memory data - a type for dtype Int32 gets int32 data etc.
</summary>
</member>
<member name="T:DiffSharp.Backends.BackendTensorStatics">
 <summary>
   Represents the static functionality for tensors implemented by a DiffSharp backend.
 </summary>

 <namespacedoc>
   <summary>Contains types and functionality related to backend implementations for DiffSharp.</summary>
 </namespacedoc>
</member>
<member name="M:DiffSharp.Compose.dsharp.move.Static(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.cast.Static(DiffSharp.Dtype)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.toImageString.Static(Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.toImage.Static(Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.pad.Static(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.convTranspose3d.Static(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.convTranspose2d.Static(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.convTranspose1d.Static(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.conv3d.Static(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.conv2d.Static(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.conv1d.Static(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.maxunpool3d.Static(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.maxunpool2d.Static(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.maxunpool1d.Static(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.maxpool3d.Static(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.maxpool2d.Static(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.maxpool1d.Static(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.crossEntropyLoss.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.nllLoss.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.bceLoss.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.mseLoss.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.logsumexp.Static(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.logsoftmax.Static(System.Int32)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.softmax.Static(System.Int32)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.leakyRelu.Static(Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.unflatten.Static(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.flatten.Static(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.viewAs.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.view.Static(System.Int32)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.view.Static(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.slice.Static(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.repeat.Static(System.Int32,System.Int32)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.undilate.Static(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.dilate.Static(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.flip.Static(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.unsqueezeAs.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.unsqueeze.Static(System.Int32)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.squeeze.Static(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.transpose.Static(System.Int32,System.Int32)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.scatter.Static(System.Int32,DiffSharp.Tensor,System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.gather.Static(System.Int32,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.corrcoef.Static">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.cov.Static(Microsoft.FSharp.Core.FSharpOption{System.Int64},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.std.Static(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.var.Static(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.mean.Static(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.sum.Static(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.dot.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.matmul.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.pow.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.div.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.mul.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.sub.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.add.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.split.Static(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.cat.Static(System.Int32)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.unstack.Static(System.Int32)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.stack.Static(System.Int32)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.expandAs.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.expand.Static(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.diagonal.Static(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.clamp.Static(Microsoft.FSharp.Core.FSharpOption{System.IConvertible},Microsoft.FSharp.Core.FSharpOption{System.IConvertible})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.eq.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.ge.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.le.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.gt.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.lt.Static(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.like.Static(System.Object,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.randintLike.Static(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.randnLike.Static(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.randLike.Static(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.onehotLike.Static(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.logspaceLike.Static(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.logspaceLike.Static(System.Double,System.Double,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.linspaceLike.Static(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.linspaceLike.Static(System.Double,System.Double,System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.arangeLike.Static(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.arangeLike.Static(System.Double,Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.fullLike.Static(System.IConvertible,Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.onesLike.Static(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.zerosLike.Static(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.dropout3d.Static(Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.dropout2d.Static(Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.dropout.Static(Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.bernoulli.Static(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Compose.dsharp.multinomial.Static(System.Int32,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
 <summary>Returns a tensor where each row contains <paramref name="numSamples"/> indices sampled from the multinomial probability distribution located in the corresponding row of tensor input.</summary>
 <param name="numSamples">Number of samples to draw</param>
 <param name="device">The desired device of returned tensor. Default: if None, uses Device.Default.</param>
 <param name="dtype">The desired element type of returned tensor. Default: if None, uses Dtype.Default.</param>
 <param name="backend">The desired backend of returned tensor. Default: if None, uses Backend.Default.</param>
 <remarks>
 Indices are ordered from left to right according to when each was sampled (first samples are placed in first column).
 
 If input is a vector, out is a vector of size num_samples.
 
 If input is a matrix with m rows, the result is an matrix of shape (m × numSamples)
 </remarks>
</member>
<member name="M:DiffSharp.Compose.dsharp.tensor.Static``1(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.fj.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.fvjp.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.fjvp.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.fghvp.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.fh.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.fhvp.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.fgh.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.fg.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.fgvp.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.j.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.vjp.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.jvp.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.ghvp.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.gh.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.h.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.hvp.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.g.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Shorten.dsharp.gvp.Static(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numcurldivergence.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numfcurldivergence.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numdivergence.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numfdivergence.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numcurl.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numfcurl.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numlaplacian.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numflaplacian.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numhessianv.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numfhessianv.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numhessian.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numfhessian.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numgradhessian.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numfgradhessian.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numgrad.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numfgrad.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numfgradv.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numgradv.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numjacobian.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numfjacobian.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numfjacobianv.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numjacobianv.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numdiff2.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numfdiff2.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numfdiff.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.dsharp.numdiff.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numfj.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numfjvp.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numfgh.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numfh.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numfhvp.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numfg.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numfgvp.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numj.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numjvp.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numgh.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numh.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numhvp.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numg.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Numerical.Shorten.dsharp.numgvp.Static(System.Double,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Empirical`1.unweighted">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Empirical`1.thin(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Empirical`1.sample">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Empirical`1.sample(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Empirical`1.resample(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Empirical`1.map``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Empirical`1.logprob(`0)">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.weights">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.variance">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.valuesTensor">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.values">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.stddev">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.mode">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.min">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.mean">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.max">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.logWeights">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.length">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.isWeighted">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.effectiveSampleSize">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Empirical`1.Item(System.Int32)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Empirical`1.filter(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Empirical`1.expectation(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Empirical`1.combineDuplicates">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Empirical`1.ToString">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Empirical`1.GetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Distributions.Empirical`1">
 <summary>Represents an Empirical distribution.</summary>
</member>
<member name="M:DiffSharp.Distributions.Categorical.sample">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Categorical.logprob(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Categorical.stddev">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Categorical.probs">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Categorical.mean">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Categorical.logits">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Categorical.eventShape">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Categorical.batchShape">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Distributions.Categorical">
 <summary>Represents a Categorial distribution.</summary>
</member>
<member name="M:DiffSharp.Distributions.Bernoulli.sample">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Bernoulli.logprob(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Bernoulli.variance">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Bernoulli.probs">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Bernoulli.mean">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Bernoulli.logits">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Bernoulli.eventShape">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Bernoulli.batchShape">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Bernoulli.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Distributions.Bernoulli">
 <summary>Represents a Bernoulli distribution.</summary>
</member>
<member name="M:DiffSharp.Distributions.Uniform.sample">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Uniform.logprob(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Uniform.variance">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Uniform.range">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Uniform.mean">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Uniform.low">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Uniform.high">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Uniform.eventShape">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Uniform.batchShape">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Uniform.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Distributions.Uniform">
 <summary>Represents a uniform distribution with low and high values drawn from the given tensors.</summary>
</member>
<member name="M:DiffSharp.Distributions.Normal.sample">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Normal.logprob(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Normal.stddev">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Normal.mean">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Normal.eventShape">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.Normal.batchShape">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Normal.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Distributions.Normal">
 <summary>Represents a normal distribution with the given mean and standard deviation with the mean and standard deviation drawn fom the given tensors.</summary>
</member>
<member name="M:DiffSharp.Distributions.TensorDistribution.sample(System.Int32)">
 <summary>Samples the distribution mutliple times</summary>
</member>
<member name="M:DiffSharp.Distributions.TensorDistribution.prob(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.TensorDistribution.variance">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.TensorDistribution.stddev">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.TensorDistribution.mean">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Distributions.TensorDistribution.eventShape">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Distributions.Distribution`1.sample">
 <summary>Samples the distribution</summary>
</member>
<member name="M:DiffSharp.Distributions.Distribution`1.logprob(`0)">
 <summary>Returns the log-probability of the distribution</summary>
</member>
<member name="T:DiffSharp.Distributions.Distribution`1">
 <namespacedoc>
   <summary>Contains types and functionality related to probabilitity distributions.</summary>
 </namespacedoc>

 <summary>Represents a distribution.</summary>
</member>
<member name="T:DiffSharp.Data.Dataset">
 <namespacedoc>
   <summary>Contains datasets and components related to data loading.</summary>
 </namespacedoc>

 <summary>Represents a dataset.</summary>
</member>
<member name="M:DiffSharp.Model.Weight.uniform(System.Collections.Generic.IEnumerable{System.Int32},System.Double)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Weight.kaiming(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Double})">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.Weight">
 <summary>Contains functionality related to generating initial parameter weights for models.</summary>
</member>
<member name="M:DiffSharp.Model.Model`2.op_MinusMinusGreater(`0,DiffSharp.Model.Model{`0,`1})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Model`2.op_MinusMinusGreater``1(Microsoft.FSharp.Core.FSharpFunc{`0,`1},DiffSharp.Model.Model{`1,``0})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Model`2.op_MinusMinusGreater``1(DiffSharp.Model.Model{`0,`1},Microsoft.FSharp.Core.FSharpFunc{`1,``0})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Model`2.op_MinusMinusGreater``1(DiffSharp.Model.Model{`0,`1},DiffSharp.Model.Model{`1,``0})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Model`2.forward(`0)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Model`2.compose``1(DiffSharp.Model.Model{`0,`1},DiffSharp.Model.Model{`1,``0})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Model`2.clone">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Model`2.asFunction(DiffSharp.Tensor,`0)">
 <summary>Use the model as a function of its parameters and input.</summary>
 <remarks>
    The resulting function can be composed with a loss function and differentiated.
    During execution the parameters of the model are temporarily set to the supplied parameters.
 </remarks>
</member>
<member name="T:DiffSharp.Model.Model`2">
 <summary>Represents a model, primarily a collection of named parameters and sub-models and a function governed by them.</summary>
</member>
<member name="F:DiffSharp.Model.ModelBase.namePrefixes">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ModelBase.train">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ModelBase.summary">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.stateVector(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.state(DiffSharp.Model.ParameterDict)">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.parametersVector(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.parameters(DiffSharp.Model.ParameterDict)">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.buffersVector(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.buffers(DiffSharp.Model.ParameterDict)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ModelBase.reverseDiff(Microsoft.FSharp.Core.FSharpOption{System.UInt32})">
 <summary>
  Adjust the parameters of the model to initiate a new level of reverse-mode automatic differentiation.
 </summary>
 <param name="nestingTag">The level tag for nested differentiation.  Defaults to the current global nesting level</param>
 <remarks>
  After this call the current parameters of the model will support reverse-mode differentiation. After the completion
  of the corresponding <c>reverse</c> operation, the computed derivatives will be available. 
 </remarks>
</member>
<member name="M:DiffSharp.Model.ModelBase.noDiff">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ModelBase.move(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>Moves the state (parameters and buffers) of the model to the given configuration</summary>
</member>
<member name="M:DiffSharp.Model.ModelBase.init(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,DiffSharp.Tensor},DiffSharp.Tensor})">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.stateVector">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.state">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.parametersVector">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.parameters">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.nstate">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.nparameters">
 <summary>Gets the number of parameters of the Model</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.nbuffers">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.hasOwnState">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.hasOwnParameters">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.hasOwnBuffers">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.descendants">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.children">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.buffersVector">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ModelBase.buffers">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ModelBase.forwardDiff(DiffSharp.Model.ParameterDict,Microsoft.FSharp.Core.FSharpOption{System.UInt32})">
 <summary>
  Adjust the parameters of the model to initiate a new level of forward-mode automatic differentiation.
 </summary>
 <param name="derivatives">The derivatives of the parameters</param>
 <param name="nestingTag">The level tag for nested differentiation.  Defaults to the current global nesting level</param>
 <remarks>
  After this call the current parameters of the model will have attached derivatives for forward mode differentiation.
 </remarks>
</member>
<member name="M:DiffSharp.Model.ModelBase.eval">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ModelBase.clone">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ModelBase.addParameter(DiffSharp.Model.Parameter[],Microsoft.FSharp.Core.FSharpOption{System.String[]})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ModelBase.addModel(DiffSharp.Model.ModelBase[],Microsoft.FSharp.Core.FSharpOption{System.String[]})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ModelBase.addBuffer(DiffSharp.Model.Parameter[],Microsoft.FSharp.Core.FSharpOption{System.String[]})">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.ModelBase">
 <summary>Represents the base class of all models.</summary>
</member>
<member name="T:DiffSharp.Model.Mode">
 <summary>Indicates the training or evaluation mode for a model.</summary>
</member>
<member name="F:DiffSharp.Model.ParameterDict.parameters@">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.unflattenToNew(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.unflatten(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ParameterDict.Item(System.String,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.set(DiffSharp.Model.ParameterDict,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.reverseDiff(Microsoft.FSharp.Core.FSharpOption{System.UInt32})">
 <summary>
  Adjust the parameters to include support for reverse-mode automatic differentiation.
 </summary>
 <param name="nestingTag">The level tag for nested differentiation.  Defaults to the current global nesting level</param>
 <remarks>
  After this call the current parameters in this dictionary will support reverse-mode differentiation. After the completion
  of the corresponding <c>reverse</c> operation, the computed derivative
  will be available. 
 </remarks>
</member>
<member name="M:DiffSharp.Model.ParameterDict.noDiff">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.move(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.map(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Model.Parameter,DiffSharp.Model.Parameter})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.map(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,DiffSharp.Model.Parameter},System.Tuple{System.String,DiffSharp.Model.Parameter}})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.iter(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,DiffSharp.Model.Parameter},Microsoft.FSharp.Core.Unit})">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ParameterDict.parameters">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ParameterDict.nelement">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.ParameterDict.Item(System.String)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.forwardDiff(DiffSharp.Model.ParameterDict,Microsoft.FSharp.Core.FSharpOption{System.UInt32})">
 <summary>
  Adjust the parameters to include support for forward-mode automatic differentiation.
 </summary>
 <param name="derivatives">The derivatives of the parameters</param>
 <param name="nestingTag">The level tag for nested differentiation.  Defaults to the current global nesting level</param>
 <remarks>
  After this call the current parameters in this dictionary will have attached derivatives for forward mode differentiation.
 </remarks>
</member>
<member name="M:DiffSharp.Model.ParameterDict.flatten(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.copy">
 <summary>TBD</summary>
 <remarks>
   This method discards differentiability and returns a ParameterDict containing parameters that are constant tensors.
 </remarks>    /// 
</member>
<member name="M:DiffSharp.Model.ParameterDict.clear">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.add(DiffSharp.Model.ParameterDict)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.add(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,DiffSharp.Model.Parameter}})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.add``1(``0,DiffSharp.Model.Parameter)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ParameterDict.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.ParameterDict">
 <summary>Represents a collection of named parameters.</summary>
</member>
<member name="M:DiffSharp.Model.Parameter.reverseDiff(Microsoft.FSharp.Core.FSharpOption{System.UInt32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Parameter.noDiff">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Parameter.move(Microsoft.FSharp.Core.FSharpOption{DiffSharp.Device},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Dtype},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Backend})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Parameter.forwardDiff(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.UInt32})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Parameter.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.Parameter">
 <namespacedoc>
   <summary>Contains types and functionality related to describing models.</summary>
 </namespacedoc>

 <summary>Represents a parameter.</summary>
 <remarks>A parameter is a mutable register holding a tensor.</remarks>
</member>
<member name="P:DiffSharp.Model.Linear.weight(DiffSharp.Tensor)">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.Linear.bias(DiffSharp.Tensor)">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.Linear.weight">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.Linear.bias">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="M:DiffSharp.Model.Linear.forward(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Linear.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.Linear">
 <summary>A model that applies a linear transformation to the incoming data: \(y = xA^T + b\)</summary>
</member>
<member name="P:DiffSharp.Model.Conv3d.weight(DiffSharp.Tensor)">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.Conv3d.bias(DiffSharp.Tensor)">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.Conv3d.weight">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.Conv3d.bias">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="M:DiffSharp.Model.Conv3d.forward(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Conv3d.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.Conv3d">
 <summary>A model that applies a 3D convolution over an input signal composed of several input planes</summary>
</member>
<member name="P:DiffSharp.Model.Conv2d.weight(DiffSharp.Tensor)">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.Conv2d.bias(DiffSharp.Tensor)">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.Conv2d.weight">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.Conv2d.bias">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="M:DiffSharp.Model.Conv2d.forward(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Conv2d.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.Conv2d">
 <summary>A model that applies a 2D convolution over an input signal composed of several input planes</summary>
</member>
<member name="P:DiffSharp.Model.Conv1d.weight(DiffSharp.Tensor)">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.Conv1d.bias(DiffSharp.Tensor)">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.Conv1d.weight">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.Conv1d.bias">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="M:DiffSharp.Model.Conv1d.forward(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Conv1d.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.Conv1d">
 <summary>A model that applies a 1D convolution over an input signal composed of several input planes</summary>
</member>
<member name="P:DiffSharp.Model.ConvTranspose3d.weight(DiffSharp.Tensor)">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.ConvTranspose3d.bias(DiffSharp.Tensor)">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.ConvTranspose3d.weight">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.ConvTranspose3d.bias">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="M:DiffSharp.Model.ConvTranspose3d.forward(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ConvTranspose3d.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.ConvTranspose3d">
 <summary>A model that applies a 3D transposed convolution operator over an input image composed of several input planes.</summary>
</member>
<member name="P:DiffSharp.Model.ConvTranspose2d.weight(DiffSharp.Tensor)">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.ConvTranspose2d.bias(DiffSharp.Tensor)">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.ConvTranspose2d.weight">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.ConvTranspose2d.bias">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="M:DiffSharp.Model.ConvTranspose2d.forward(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ConvTranspose2d.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.ConvTranspose2d">
 <summary>A model that applies a 2D transposed convolution operator over an input image composed of several input planes.</summary>
</member>
<member name="P:DiffSharp.Model.ConvTranspose1d.weight(DiffSharp.Tensor)">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.ConvTranspose1d.bias(DiffSharp.Tensor)">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.ConvTranspose1d.weight">
 <summary>Get or set the weight parameter of the model</summary>
</member>
<member name="P:DiffSharp.Model.ConvTranspose1d.bias">
 <summary>Get or set the bias parameter of the model</summary>
</member>
<member name="M:DiffSharp.Model.ConvTranspose1d.forward(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.ConvTranspose1d.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.ConvTranspose1d">
 <summary>A model that applies a 1D transposed convolution operator over an input image composed of several input planes.</summary>
</member>
<member name="M:DiffSharp.Model.Dropout3d.forward(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Dropout3d.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.Dropout3d">
 <summary>A model which during training, randomly zero out entire channels. Each channel will be zeroed out independently on every forward call with probability p using samples from a Bernoulli distribution.</summary>
</member>
<member name="M:DiffSharp.Model.Dropout2d.forward(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Dropout2d.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.Dropout2d">
 <summary>A model which during training, randomly zero out entire channels. Each channel will be zeroed out independently on every forward call with probability p using samples from a Bernoulli distribution.</summary>
</member>
<member name="M:DiffSharp.Model.Dropout.forward(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.Dropout.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.Dropout">
 <summary>A model which during training, randomly zeroes some of the elements of the input tensor with probability p using samples from a Bernoulli distribution.</summary>
</member>
<member name="P:DiffSharp.Model.BatchNorm3d.weight">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.BatchNorm3d.variance">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.BatchNorm3d.stddev">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.BatchNorm3d.mean">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.BatchNorm3d.bias">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.BatchNorm3d.forward(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.BatchNorm3d.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.BatchNorm3d">
 <summary>Applies Batch Normalization over a 5D input (a mini-batch of 3D inputs with optional additional channel dimension)</summary>
 <remarks>
    <para>
        The mean and standard-deviation are calculated per-dimension over the mini-batches and
        \(\gamma\( and \(\beta\) are learnable parameter vectors of size \(C\) (where \(C\) is the
        input size). By default, the elements of \(\gamma\) are set to 1 and the elements of 
        \(\beta\) are set to 0. The standard-deviation is calculated via the biased estimator,
        equivalent to <c>dsharp.var(input, unbiased=False)</c>.
    </para>
    <para>
        Also by default, during training this layer keeps running estimates of its computed mean
        and variance, which are then used for normalization during evaluation. The running estimates
        are kept with a default momentum of 0.1.
    </para>
    <para>
       If trackRunningStats is set to False, this layer then does not keep running estimates,
       and batch statistics are instead used during evaluation time as well.
    </para>
 </remarks>
</member>
<member name="P:DiffSharp.Model.BatchNorm2d.weight">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.BatchNorm2d.variance">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.BatchNorm2d.stddev">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.BatchNorm2d.mean">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.BatchNorm2d.bias">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.BatchNorm2d.forward(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.BatchNorm2d.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.BatchNorm2d">
 <summary>Applies Batch Normalization over a 4D input (a mini-batch of 2D inputs with optional additional channel dimension)</summary>
 <remarks>
    <para>
        The mean and standard-deviation are calculated per-dimension over the mini-batches and
        \(\gamma\( and \(\beta\) are learnable parameter vectors of size \(C\) (where \(C\) is the
        input size). By default, the elements of \(\gamma\) are set to 1 and the elements of 
        \(\beta\) are set to 0. The standard-deviation is calculated via the biased estimator,
        equivalent to <c>dsharp.var(input, unbiased=False)</c>.
    </para>
    <para>
        Also by default, during training this layer keeps running estimates of its computed mean
        and variance, which are then used for normalization during evaluation. The running estimates
        are kept with a default momentum of 0.1.
    </para>
    <para>
       If trackRunningStats is set to False, this layer then does not keep running estimates,
       and batch statistics are instead used during evaluation time as well.
    </para>
 </remarks>
</member>
<member name="P:DiffSharp.Model.BatchNorm1d.weight">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.BatchNorm1d.variance">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.BatchNorm1d.stddev">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.BatchNorm1d.mean">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Model.BatchNorm1d.bias">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.BatchNorm1d.forward(DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Model.BatchNorm1d.ToString">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Model.BatchNorm1d">
 <summary>Applies Batch Normalization over a 2D or 3D input (a mini-batch of 1D inputs with optional additional channel dimension)</summary>
 <remarks>
    <para>
        The mean and standard-deviation are calculated per-dimension over the mini-batches and
        \(\gamma\( and \(\beta\) are learnable parameter vectors of size \(C\) (where \(C\) is the
        input size). By default, the elements of \(\gamma\) are set to 1 and the elements of 
        \(\beta\) are set to 0. The standard-deviation is calculated via the biased estimator,
        equivalent to <c>dsharp.var(input, unbiased=False)</c>.
    </para>
    <para>
        Also by default, during training this layer keeps running estimates of its computed mean
        and variance, which are then used for normalization during evaluation. The running estimates
        are kept with a default momentum of 0.1.
    </para>
    <para>
       If trackRunningStats is set to False, this layer then does not keep running estimates,
       and batch statistics are instead used during evaluation time as well.
    </para>
 </remarks>
</member>
<member name="T:DiffSharp.Model.LSTM">
 <summary>Long short-term memory (LSTM) recurrent neural network.</summary>
</member>
<member name="T:DiffSharp.Model.RNN">
 <summary>Recurrent neural network.</summary>
</member>
<member name="T:DiffSharp.Model.LSTMCell">
 <summary>Unit cell of a long short-term memory (LSTM) recurrent neural network. Prefer using the RNN class instead, which can combine RNNCells in multiple layers.</summary>
</member>
<member name="T:DiffSharp.Model.RNNCell">
 <summary>Unit cell of a recurrent neural network. Prefer using the RNN class instead, which can combine RNNCells in multiple layers.</summary>
</member>
<member name="T:DiffSharp.Model.VAEMLP">
 <summary>Variational auto-encoder with multilayer perceptron (MLP) encoder and decoder.</summary>
</member>
<member name="T:DiffSharp.Model.VAE">
 <summary>Variational auto-encoder</summary>
</member>
<member name="T:DiffSharp.Model.VAEBase">
 <summary>Variational auto-encoder base</summary>
</member>
<member name="M:DiffSharp.Optim.optim.sgd(DiffSharp.Model.Model{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Data.DataLoader,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Optim.optim.sgd(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Optim.optim.optimizeModel(DiffSharp.Model.Model{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Optim.Optimizer,DiffSharp.Data.DataLoader,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Optim.optim.adam(DiffSharp.Model.Model{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Data.DataLoader,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor}},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Optim.optim.adam(Microsoft.FSharp.Core.FSharpFunc{DiffSharp.Tensor,DiffSharp.Tensor},DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{DiffSharp.Tensor},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Double},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Optim.optim">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Optim.Adam.updateRule(System.String,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Optim.Adam">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Optim.SGD.updateRule(System.String,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Optim.SGD">
 <summary>TBD</summary>
</member>
<member name="F:DiffSharp.Optim.Optimizer.stateStep@">
 <summary>TBD</summary>
</member>
<member name="F:DiffSharp.Optim.Optimizer.model@">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Optim.Optimizer.updateRule(System.String,DiffSharp.Tensor)">
 <summary>TBD</summary>
</member>
<member name="M:DiffSharp.Optim.Optimizer.step">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Optim.Optimizer.stateStep(System.Int32)">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Optim.Optimizer.stateStep">
 <summary>TBD</summary>
</member>
<member name="P:DiffSharp.Optim.Optimizer.model">
 <summary>TBD</summary>
</member>
<member name="T:DiffSharp.Optim.Optimizer">
 <namespacedoc>
   <summary>Contains types and functionality related to optimizing models and functions.</summary>
 </namespacedoc>

 <summary>Represents an optimizer.</summary>
</member>
<member name="M:DiffSharp.OpAvgPoolExtensions.dsharp.avgpool3d.Static(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 2D average pooling over an input signal composed of several input planes, returning the max indices along with the outputs.</summary>
 <param name="input">The input tensor.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSize.</param>
 <param name="paddings">The implicit zero paddings to be added on both sides.</param>
</member>
<member name="M:DiffSharp.OpAvgPoolExtensions.dsharp.avgpool2d.Static(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 2D average pooling over an input signal composed of several input planes, returning the max indices along with the outputs.</summary>
 <param name="input">The input tensor.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSize.</param>
 <param name="paddings">The implicit zero paddings to be added on both sides.</param>
</member>
<member name="M:DiffSharp.OpAvgPoolExtensions.dsharp.avgpool1d.Static(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Applies a 1D average pooling over an input signal composed of several input planes, returning the max indices along with the outputs.</summary>
 <param name="input">The input tensor.</param>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
</member>
<member name="M:DiffSharp.OpAvgPoolExtensions.Tensor.avgpool3d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 3D average pooling over an input signal composed of several input planes, returning the max indices along with the outputs.</summary>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSize.</param>
 <param name="paddings">The implicit zero paddings to be added on both sides.</param>
</member>
<member name="M:DiffSharp.OpAvgPoolExtensions.Tensor.avgpool2d(DiffSharp.Tensor,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{System.Int32}})">
 <summary>Applies a 1D average pooling over an input signal composed of several input planes, returning the max indices along with the outputs.</summary>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
 <param name="kernelSizes">The sizes of the window to take a max over.</param>
 <param name="strides">The strides of the window. Default value is kernelSize.</param>
 <param name="paddings">The implicit zero paddings to be added on both sides.</param>
</member>
<member name="M:DiffSharp.OpAvgPoolExtensions.Tensor.avgpool1d(DiffSharp.Tensor,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>Applies a 1D average pooling over an input signal composed of several input planes, returning the max indices along with the outputs.</summary>
 <param name="kernelSize">The size of the window to take a max over.</param>
 <param name="stride">The stride of the window. Default value is kernelSize.</param>
 <param name="padding">The implicit zero padding to be added on both sides.</param>
</member>
<member name="M:DiffSharp.OpBMMExtensions.dsharp.bmm.Static(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Batched matrix product of two tensors. Tensors <paramref name="a" /> and  <paramref name="b" /> must be 3d tensors each containing the same number of matrices. If <paramref name="a" /> is a \(b \times n \times m\) tensor, <paramref name="b" /> is a \(b \times m \times p\) tensor, the result will be a \(b \times n \times p\) tensor.</summary>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.OpBMMExtensions.Tensor.bmm(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Batched matrix product of two tensors. Tensors <paramref name="b" /> must be 3d tensors each containing the same number of matrices. If the tensor is a \(b \times n \times m\) tensor, and <paramref name="b" /> is a \(b \times m \times p\) tensor, the result will be a \(b \times n \times p\) tensor.</summary>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.OpOuterExtensions.dsharp.outer.Static(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Outer product of two tensors.</summary>
 <param name="a">The first tensor.</param>
 <param name="b">The second tensor.</param>
</member>
<member name="M:DiffSharp.OpOuterExtensions.Tensor.outer(DiffSharp.Tensor,DiffSharp.Tensor)">
 <summary>Outer product of two tensors.</summary>
 <param name="b">The second tensor.</param>
</member>
</members>
</doc>
